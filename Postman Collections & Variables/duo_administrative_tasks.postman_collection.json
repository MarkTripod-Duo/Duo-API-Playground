{
	"info": {
		"_postman_id": "c8d17b77-2c05-47db-8f54-6c5c00f2a498",
		"name": "Duo Administrative Tasks",
		"description": "In this collection, we've included a number of requests to address some common MSP use cases.\n\n_**Note:**_ Be sure to refer to the **Duo Accounts API** and **Duo Admin API \\[Parent\\]** collections, and ensure the Accounts API and Admin request credentials have been populated in the global variables before continuing. If you do not poulate the variables as defined in those two collections, some requst in this collection will not work properly.\n\n#### ðŸš€ Getting familiar with this collection\n\n- **Bypass Users:** The requests in this folder allow pulling a list of users in Bypass status across all sub-accounts and _if desired_ setting those users to Active status\n    - _Get Users in Bypass status:_ Pulls the full list of users in Bypass status accross all child accounts and stores the users in the `bypassUserList` global variable.\n    - _Set users in Bypass status to Active status:_ Iterates over that list of users in the `bypassUserList`, and sends individual calls to each account to set these users to 'Active' status.\n    - **Note:** _The sequence of requests is comprehensive. If you have users you wish to maintain in 'Bypass' status, they should be removed from the_ `bypassUserList` _global variable before running the 'Set Users in Bypass status to Active' request._\n- **Cost Report:** The \"Cost Report\" comprises multiple request designed to provide a detailed breakdown of your current Duo usage, including the total number of users, the associated edition (Essentials, Advantage, Premier), and the corresponding costs. It provides both a console-friendly table and a CSV report of each client's Duo usage.\n    - **Important Note**: _The Duo Admin API doesn't offer a method to retrieve the edition of the parent account natively, so to work aroud this, we have added a collection variable_ `parent_account_edition_`_that must be manually set to the edition of the parent account. It must be one of..._\n        - Duo Essentials\n        - Duo Advantage\n        - Duo Premier\n    - Before starting, ensure that the edition name is spelled correctly in the collection variable. If an edition name is misspelled or missing, the function will not run successfully.\n- **Push Phish Simulator:** This collection enables Duo administrators to conduct a phishing test using Duo Push or Phone Call on a select user group. By simulating authentication requests, it helps administrators assess whether users can distinguish and approve only legitimate authentication attempts.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "27165404",
		"_collection_link": "https://duomsp.postman.co/workspace/Duo-MSP-API-Playground~c7115430-1cbf-4f66-9ded-2a737488a755/collection/27165404-c8d17b77-2c05-47db-8f54-6c5c00f2a498?action=share&source=collection_link&creator=27165404"
	},
	"item": [
		{
			"name": "Bypass Users",
			"item": [
				{
					"name": "Users in 'Bypass' status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Initialize DuoChildAccounts as an empty object\r",
									"var DuoChildAccounts = {};\r",
									"\r",
									"// HMAC 1 - Get HMAC authentication header\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY\r",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname\r",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type\r",
									"\r",
									"    // Check if the API hostname is defined. If not, throw an error.\r",
									"    if (!API_HOSTNAME) {\r",
									"        throw new Error(\"API_HOSTNAME is not defined\");\r",
									"    }\r",
									"     \r",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    // Get the index of the start of the query parameters in the URL \r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"\r",
									"    // Calculate the length of the hostname\r",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;\r",
									"\r",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call\r",
									"     \r",
									"    // Clean up api_call by removing any unwanted characters\r",
									"    api_call = api_call.replace(\"}}\", \"\");\r",
									"    // console.log('api_call:', api_call);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"    //Create unsorted array of parameters from either URL or Body\r",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL\r",
									"    //(technically it looks like POST can be in the URL as well)\r",
									"\r",
									"    // Depending on the HTTP method and the existence of a request body,\r",
									"    // extract the query parameters from the URL or the body into params_array\r",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {\r",
									"        for (var parameter1 in requestBody) {\r",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart+1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"     \r",
									"    params_array.sort();                    //lexicographically sort parameters by key\r",
									"    var encoded_params = \"\";               \r",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array\r",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &\r",
									"    }\r",
									"     \r",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\",timestamp);\r",
									" \r",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines\r",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;\r",
									"    // console.log(requestData);\r",
									" \r",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"     \r",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.\r",
									"    var prebase = IKEY+\":\"+ hmacDigest;\r",
									"    // console.log(\"prebase:\", prebase)\r",
									"     \r",
									"    //encodes a string in base-64\r",
									"    var baseComplete = btoa(prebase);\r",
									"\r",
									"    var authHeader = \"Basic \"+ baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"// HMAC 2 - Get HMAC authentication header\r",
									"function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
									"    var AUTH_TYPE = 'HMAC-SHA1';\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8;\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        for (var parameter1 in requestBody) {\r",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var baseComplete = btoa(prebase);\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"// Request 1 - Get Accounts\r",
									"function getAccounts() {\r",
									"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;\r",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url1,\r",
									"        method: \"POST\",\r",
									"        header: {\r",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
									"            \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"        },\r",
									"        body: {}\r",
									"    }, function(err, res) {\r",
									"        if (err) {\r",
									"            console.log(\"Error:\", err);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        try {\r",
									"            var responseJson = JSON.parse(res.text());\r",
									"            if (responseJson.stat === \"OK\") {\r",
									"                var DuoChildAccounts = {};\r",
									"                responseJson.response.forEach(account => {\r",
									"                    DuoChildAccounts[account.account_id] = {\r",
									"                        name: account.name,\r",
									"                        apiHostname: account.api_hostname\r",
									"                    };\r",
									"                });\r",
									"\r",
									"                // Save the mapping object as a global variable\r",
									"                pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));\r",
									"\r",
									"                // Proceed to the next request\r",
									"                getBypassUsers(DuoChildAccounts);\r",
									"            } else {\r",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);\r",
									"            }\r",
									"        } catch (error) {\r",
									"            console.log(\"Error parsing JSON:\", error);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"// Clear Global Variables\r",
									"function clearGlobalVariables() {\r",
									"    pm.globals.unset(\"timestampHeader\");\r",
									"    pm.globals.unset(\"hmacAuthHeader\");\r",
									"    pm.globals.unset(\"hmacAuthHeader2\");\r",
									"    pm.globals.unset(\"accountId\");\r",
									"    pm.globals.unset(\"next_offset\");\r",
									"}\r",
									"\r",
									"// Request 2 - Get Bypass Users\r",
									"function getBypassUsers(DuoChildAccounts) {\r",
									"    var bypassUserList = {};\r",
									"    var keys = Object.keys(DuoChildAccounts);\r",
									"    processAccount(keys, 0);\r",
									"\r",
									"    function processAccount(keys, index, offset = 0) {\r",
									"        if (index >= keys.length) {\r",
									"            // All accounts have been processed\r",
									"            console.log(\"Bypass Users List\");\r",
									"            let bypassUserFound = false;\r",
									"            for (let accountId in bypassUserList) {\r",
									"                let accountData = bypassUserList[accountId];\r",
									"                if (accountData.users.length > 0) {\r",
									"                    bypassUserFound = true;\r",
									"                    // console.log(\"Account Name\\t\\tBypass Users\");\r",
									"                   console.log(`${accountData.account_name}: ${accountData.users.map(user => user.username).join(\", \")}`);\r",
									"                }\r",
									"            }\r",
									"\r",
									"            if (!bypassUserFound) {\r",
									"                console.log(\"There are no users in Bypass status across your client accounts.\");\r",
									"                // No need to set bypassUserList as a global variable if no users found\r",
									"            } else {\r",
									"                pm.globals.set(\"bypassUserList\", JSON.stringify(bypassUserList));\r",
									"            }\r",
									"\r",
									"            clearGlobalVariables(); // Clear global variables after processing\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        let accountId = keys[index];\r",
									"        var accountDetails = DuoChildAccounts[accountId];\r",
									"        var urlWithAccountId = `https://${accountDetails.apiHostname}/admin/v1/users?account_id=${accountId}&offset=${offset}`;\r",
									"\r",
									"        pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", urlWithAccountId, {}, accountDetails.apiHostname));\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: urlWithAccountId,\r",
									"            method: \"GET\",\r",
									"            header: {\r",
									"                \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),\r",
									"                \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"            },\r",
									"            body: {}\r",
									"        }, function(err, res) {\r",
									"            if (err) {\r",
									"                console.error('Request failed for account:', accountDetails.name, '; Error:', err);\r",
									"                processAccount(keys, index + 1);\r",
									"                return;\r",
									"            }\r",
									"\r",
									"            if (res.code === 200) {\r",
									"                var resJson = res.json();\r",
									"                var bypassUsers = resJson.response.filter(user => user.status === 'bypass')\r",
									"                    .map(user => ({ username: user.username, user_id: user.user_id }));\r",
									"\r",
									"                if (bypassUsers.length > 0) {\r",
									"                    if (!bypassUserList[accountId]) {\r",
									"                        bypassUserList[accountId] = {\r",
									"                            account_name: accountDetails.name,\r",
									"                            users: []\r",
									"                        };\r",
									"                    }\r",
									"                    bypassUserList[accountId].users.push(...bypassUsers);\r",
									"                }\r",
									"\r",
									"                // Check for next offset\r",
									"                if (resJson.metadata && resJson.metadata.next_offset) {\r",
									"                    processAccount(keys, index, resJson.metadata.next_offset);\r",
									"                } else {\r",
									"                    processAccount(keys, index + 1);\r",
									"                }\r",
									"            } else {\r",
									"                console.error('Request failed for account:', accountDetails.name, '; Response:', res);\r",
									"                processAccount(keys, index + 1);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"}\r",
									"\r",
									"// Start the process\r",
									"getAccounts();\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// var bypassUserList = JSON.parse(pm.globals.get(\"bypassUserList\"));",
									"",
									"// // Check if bypassUserList is empty",
									"// if (Object.keys(bypassUserList).length === 0) {",
									"//     console.log(\"There are no users in Bypass status.\");",
									"// } else {",
									"//     // List accounts with bypass users",
									"//     console.log(\"The following users are in Bypass status:\");",
									"//     for (var accountKey in bypassUserList) {",
									"//         var accountData = bypassUserList[accountKey];",
									"//         var userList = accountData.users.map(user => user.username).join(\", \");",
									"//         console.log(accountData.account_name.split(':')[0].trim() + \": \" + userList);",
									"//     }",
									"// }",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				},
				{
					"name": "Set 'Bypass' users to 'Active' status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variables declaration section\r",
									"var bypassUserListString = pm.globals.get(\"bypassUserList\");\r",
									"var bypassUserList;\r",
									"var DuoChildAccounts;\r",
									"\r",
									"try {\r",
									"    bypassUserList = JSON.parse(bypassUserListString);\r",
									"    DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
									"} catch (e) {\r",
									"    console.error(\"Error parsing JSON: \", e);\r",
									"    return; // Stop execution if parsing fails\r",
									"}\r",
									"\r",
									"// Check if bypassUserList is empty\r",
									"if (!bypassUserList || Object.keys(bypassUserList).length === 0) {\r",
									"    console.log(\"bypassUserList is empty or not defined.\");\r",
									"    clearGlobalVariables(); // Clear global variables\r",
									"    return; // Exit if there's nothing to process\r",
									"}\r",
									"\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Accounts API SKEY\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8;\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    // Ensure requestBody is an object\r",
									"    if (!requestBody || Object.keys(requestBody).length === 0) {\r",
									"        requestBody = {};\r",
									"    }\r",
									"\r",
									"    for (var parameter1 in requestBody) {\r",
									"        params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"        params_array.push(params_unsorted);\r",
									"    }\r",
									"\r",
									"    if (params_array.length === 0) {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var baseComplete = btoa(prebase);\r",
									"\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"// Loop over each Account in the bypassUserList\r",
									"for (let accountKey in bypassUserList) {\r",
									"    let accountData = bypassUserList[accountKey];\r",
									"    let accountId;\r",
									"    let accountDetails;\r",
									"\r",
									"    // Check if accountKey is a valid JSON string\r",
									"    try {\r",
									"        let parsedKey = JSON.parse(accountKey);\r",
									"        accountId = parsedKey.account_id;\r",
									"    } catch (e) {\r",
									"        // If it's not a valid JSON, use accountKey directly\r",
									"        accountId = accountKey;\r",
									"    }\r",
									"\r",
									"    accountDetails = DuoChildAccounts[accountId];\r",
									"    if (!accountDetails) {\r",
									"        console.error(\"Account details not found for account ID: \", accountId);\r",
									"        continue;\r",
									"    }\r",
									"\r",
									"    let accountName = accountDetails.name;\r",
									"    let apiHostname = accountDetails.apiHostname; // Get the apiHostname for the current account\r",
									"\r",
									"    let processedUsers = []; // Array to hold processed usernames\r",
									"    let userPromises = []; // Array to hold promises\r",
									"\r",
									"    if (Array.isArray(accountData.users)) {\r",
									"        accountData.users.forEach(function(user) {\r",
									"            // Construct the URL for the API call, using the current accountId, user_id, and specific apiHostname\r",
									"            var postUrlWithAccountIdAndUserId = `https://${apiHostname}/admin/v1/users/${user.user_id}?account_id=${accountId}&status=active`;\r",
									"\r",
									"            // Call the getAuthHeader function to generate the HMAC auth header for this API request\r",
									"            var postHmacAuthHeader = getAuthHeader(\"POST\", postUrlWithAccountIdAndUserId, {}, apiHostname);\r",
									"\r",
									"            // Create a new promise for each request\r",
									"            let userPromise = new Promise((resolve, reject) => {\r",
									"                pm.sendRequest({\r",
									"                    url: postUrlWithAccountIdAndUserId,\r",
									"                    method: \"POST\",\r",
									"                    header: {\r",
									"                        \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"                        \"Authorization\": postHmacAuthHeader,\r",
									"                        \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"                    },\r",
									"                    body: {}\r",
									"                }, function(postErr, postRes) {\r",
									"                    if (postRes.code === 200 && postRes.json().stat === \"OK\") {\r",
									"                        processedUsers.push(user.username); // Add username to the array\r",
									"                        resolve();\r",
									"                    } else {\r",
									"                        console.error(\"There was an error when processing user with ID: \" + user.user_id);\r",
									"                        console.error(postErr);\r",
									"                        reject();\r",
									"                    }\r",
									"                });\r",
									"            });\r",
									"\r",
									"            userPromises.push(userPromise);\r",
									"        });\r",
									"\r",
									"        // Wait for all promises to resolve\r",
									"        Promise.all(userPromises).then(() => {\r",
									"            if (processedUsers.length > 0) {\r",
									"                console.log(\"The following users have been set to Active status on \" + accountName + \": \" + processedUsers.join(\", \"));\r",
									"            }\r",
									"        }).catch((error) => {\r",
									"            console.error(\"Error in processing users for account:\", accountName, \"; Error:\", error);\r",
									"        });\r",
									"    } else {\r",
									"        console.error(\"Users is not an array for account:\", accountName);\r",
									"    }\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"// Get the last account data and user\r",
									"var lastAccountKeyString = Object.keys(bypassUserList).pop();\r",
									"\r",
									"if (lastAccountKeyString) {\r",
									"    var lastAccountData = bypassUserList[lastAccountKeyString];\r",
									"    var lastAccountDetails = DuoChildAccounts[lastAccountKeyString]; // Directly use lastAccountKeyString\r",
									"\r",
									"    if (lastAccountData && Array.isArray(lastAccountData.users) && lastAccountData.users.length > 0) {\r",
									"        var lastUser = lastAccountData.users[lastAccountData.users.length - 1];\r",
									"        var lastUserApiHostname = lastAccountDetails.apiHostname; // Use lastAccountDetails\r",
									"\r",
									"        // Set the global variables\r",
									"        pm.globals.set(\"user_id\", lastUser.user_id);\r",
									"        pm.globals.set(\"account_id\", lastAccountKeyString); // Use lastAccountKeyString directly\r",
									"\r",
									"        // Construct the URL for the API call\r",
									"        var mainUrlWithAccountIdAndUserId = `https://${lastUserApiHostname}/admin/v1/users/${lastUser.user_id}?account_id=${lastAccountKeyString}&status=active`;\r",
									"\r",
									"        // Call the getAuthHeader function\r",
									"        var mainHmacAuthHeader = getAuthHeader(\"POST\", mainUrlWithAccountIdAndUserId, {}, lastUserApiHostname);\r",
									"        pm.globals.set(\"hmacAuthHeader\", mainHmacAuthHeader);\r",
									"    } else {\r",
									"        console.error(\"No users found in the last account data or lastAccountData.users is not an array.\");\r",
									"    }\r",
									"} else {\r",
									"    console.error(\"lastAccountKeyString is undefined or not found in bypassUserList.\");\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"function clearGlobalVariables() {",
									"    var variablesToClear = [\"user_id\", \"account_id\", \"timestampHeader\", \"hmacAuthHeader\", \"hmacAuthHeader2\", \"bypassUserList\", \"duoChildAccounts\"];",
									"    variablesToClear.forEach(function(variableName) {",
									"        pm.globals.unset(variableName);",
									"    });",
									"    // console.log(\"Global variables cleared.\");",
									"}",
									"",
									"// Call the function to clear the variables",
									"clearGlobalVariables();",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				}
			],
			"description": "The requests in this folder allow pulling a list of users in Bypass status across all sub-accounts and _if desired_ setting those users to Active status\n\n- _Get Users in Bypass status:_ Pulls the full list of users in Bypass status accross all child accounts and stores the users in the `bypassUserList` global variable.\n    \n- _Set users in Bypass status to Active status:_ Iterates over that list of users in the `bypassUserList`, and sends individual calls to each account to set these users to 'Active' status.\n    \n- **Note:** _The sequence of requests is comprehensive. If you have users you wish to maintain in 'Bypass' status, they should be removed from the_ `bypassUserList` _global variable before running the 'Set Users in Bypass status to Active' request._",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Cost Report",
			"item": [
				{
					"name": "Cost Report",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"try {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"",
									"    var totalUsersByEdition = {};",
									"",
									"    for (let accountId in DuoChildAccounts) {",
									"        if (DuoChildAccounts.hasOwnProperty(accountId)) {",
									"            let accountDetails = DuoChildAccounts[accountId];",
									"            let edition = accountDetails.edition;",
									"            let userCount = parseInt(accountDetails.userCount, 10);",
									"",
									"            if (totalUsersByEdition.hasOwnProperty(edition)) {",
									"                totalUsersByEdition[edition] += userCount;",
									"            } else {",
									"                totalUsersByEdition[edition] = userCount;",
									"            }",
									"        }",
									"    }",
									"",
									"    var parentAccountEdition = pm.collectionVariables.get(\"parent_account_edition\");",
									"    var parentAccountUserCount = parseInt(pm.globals.get(\"parent_account_user_count\"), 10);",
									"",
									"    var parentEditionKey = \"\";",
									"    switch (parentAccountEdition) {",
									"        case \"Duo Essentials\":",
									"            parentEditionKey = \"ENTERPRISE\";",
									"            break;",
									"        case \"Duo Advantage\":",
									"            parentEditionKey = \"PLATFORM\";",
									"            break;",
									"        case \"Duo Premier\":",
									"            parentEditionKey = \"BEYOND\";",
									"            break;",
									"        default:",
									"            throw new Error(`Parent account edition is currently set to (${parentAccountEdition}). Please update the parent_account_edition collection variable to one of: Duo Essentials, Duo Advantage, or Duo Premier`);",
									"    }",
									"",
									"    if (totalUsersByEdition.hasOwnProperty(parentEditionKey)) {",
									"        totalUsersByEdition[parentEditionKey] += parentAccountUserCount;",
									"    } else {",
									"        totalUsersByEdition[parentEditionKey] = parentAccountUserCount;",
									"    }",
									"",
									"    var basePrices = {",
									"        \"ENTERPRISE\": 3,",
									"        \"PLATFORM\": 6,",
									"        \"BEYOND\": 9",
									"    };",
									"",
									"    console.log(pm.globals.get(\"parent_account_name\") + \" Account Summary \" + new Date().toLocaleString('default', { month: 'short', year: '2-digit' }));",
									"",
									"    var maxEditionLength = 0;",
									"    var maxUserCountLength = 0;",
									"    var maxDiscountTierLength = 0;",
									"    var maxUnitPriceLength = 0;",
									"    var totalUserCount = 0;",
									"",
									"    for (let edition in totalUsersByEdition) {",
									"        if (edition.length > maxEditionLength) {",
									"            maxEditionLength = edition.length;",
									"        }",
									"        let userCount = totalUsersByEdition[edition].toString();",
									"        if (userCount.length > maxUserCountLength) {",
									"            maxUserCountLength = userCount.length;",
									"        }",
									"        let discountTier = getDiscountTier(totalUsersByEdition[edition]);",
									"        if (discountTier.length > maxDiscountTierLength) {",
									"            maxDiscountTierLength = discountTier.length;",
									"        }",
									"        let basePrice = basePrices[edition] || 0;",
									"        let unitPrice = getUnitPrice(basePrice, discountTier);",
									"        let unitPriceString = unitPrice.toFixed(2);",
									"        if (unitPriceString.length > maxUnitPriceLength) {",
									"            maxUnitPriceLength = unitPriceString.length;",
									"        }",
									"        totalUserCount += totalUsersByEdition[edition];",
									"    }",
									"",
									"    var editionNames = {",
									"        \"ENTERPRISE\": \"Duo Essentials\",",
									"        \"PLATFORM\": \"Duo Advantage\",",
									"        \"BEYOND\": \"Duo Premier\"",
									"    };",
									"",
									"    console.log(\"Edition\".padEnd(maxEditionLength + 5) + \"User Count\".padEnd(maxUserCountLength + 10) + \"Base Price\".padEnd(13) + \"Discount Tier\".padEnd(maxDiscountTierLength + 12) + \"Unit Price\");",
									"",
									"    var sortedEditions = Object.keys(totalUsersByEdition).sort((a, b) => {",
									"        if (a === \"ENTERPRISE\") return -1;",
									"        if (a === \"PLATFORM\" && b !== \"ENTERPRISE\") return -1;",
									"        return 1;",
									"    });",
									"",
									"    var totalCost = 0;",
									"",
									"    for (let edition of sortedEditions) {",
									"        let userCount = totalUsersByEdition[edition];",
									"        let basePrice = basePrices[edition] || 0;",
									"        let discountTier = getDiscountTier(userCount);",
									"        let unitPrice = getUnitPrice(basePrice, discountTier);",
									"        let editionName = editionNames[edition];",
									"        console.log(editionName.padEnd(maxEditionLength + 9) + userCount.toString().padEnd(maxUserCountLength + 11) + \"$\" + basePrice.toString().padEnd(12) + discountTier.padEnd(maxDiscountTierLength + 11) + \"$\" + unitPrice.toFixed(2));",
									"",
									"        totalCost += userCount * unitPrice;",
									"    }",
									"    console.log(\"Note: Parent Account users have been included in these calculations minus the NFR adjustment\")",
									"    console.log(`Total Users: ${totalUserCount}\\n Total Cost: $${totalCost.toFixed(2)}`);",
									"",
									"    function getDiscountTier(userCount) {",
									"        var discountTier = pm.collectionVariables.get(\"discount_tier\");",
									"        if (discountTier) {",
									"            return discountTier + \"%\";",
									"        }",
									"",
									"        if (userCount >= 1 && userCount <= 999) {",
									"            return \"10%\";",
									"        } else if (userCount >= 1000 && userCount <= 4999) {",
									"            return \"20%\";",
									"        } else if (userCount >= 5000 && userCount <= 24999) {",
									"            return \"30%\";",
									"        } else if (userCount >= 25000 && userCount <= 124999) {",
									"            return \"40%\";",
									"        } else if (userCount >= 125000) {",
									"            return \"50%\";",
									"        } else {",
									"            return \"0%\";",
									"        }",
									"    }",
									"",
									"    function getUnitPrice(basePrice, discountTier) {",
									"        let discountPercentage = parseFloat(discountTier) / 100;",
									"        return basePrice - (basePrice * discountPercentage);",
									"    }",
									"",
									"    var csvContent = \"Please find a CSV breakdown of each customer's account summary below. You can copy the CSV content into the spreadsheet program of your choice (such as Microsoft Excel or Google Sheets) for easier viewing and analysis.\\n\\nAccount Name, Edition, Base Price, User Count, Cost\\n\";",
									"",
									"    for (let accountId in DuoChildAccounts) {",
									"        if (DuoChildAccounts.hasOwnProperty(accountId)) {",
									"            let accountDetails = DuoChildAccounts[accountId];",
									"            let accountName = accountDetails.name;",
									"            let edition = editionNames[accountDetails.edition];",
									"            let userCount = parseInt(accountDetails.userCount, 10);",
									"            let basePrice = basePrices[accountDetails.edition] || 0;",
									"            let cost = basePrice * userCount;",
									"            let csvLine = `${accountName},${edition},$${basePrice},${userCount},$${cost}\\n`;",
									"            csvContent += csvLine;",
									"        }",
									"    }",
									"",
									"    ",
									"    console.log(csvContent);",
									"",
									"    pm.globals.unset(\"duoChildAccounts\");",
									"",
									"} catch (error) {",
									"    console.log(\"Error:\", error);",
									"}",
									"",
									"// Deleting the variables",
									"var variablesToDelete = [",
									"    \"timestampHeader\",",
									"    \"hmacAuthHeader\",",
									"    \"hmacAuthHeader2\",",
									"    \"hmacAuthHeader3\",",
									"    \"parent_account_name\",",
									"    \"parent_account_user_count\",",
									"    \"next_offset\"",
									"];",
									"",
									"variablesToDelete.forEach(function(variableName) {",
									"    pm.globals.unset(variableName);",
									"});"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Initialize DuoChildAccounts as an empty object",
									"var DuoChildAccounts = {};",
									"",
									"// HMAC 1 - Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"    // Check if the API hostname is defined. If not, throw an error.",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"     ",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Get the index of the start of the query parameters in the URL ",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"     ",
									"    // Clean up api_call by removing any unwanted characters",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"    // console.log('api_call:', api_call);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    //Create unsorted array of parameters from either URL or Body",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL",
									"    //(technically it looks like POST can be in the URL as well)",
									"",
									"    // Depending on the HTTP method and the existence of a request body,",
									"    // extract the query parameters from the URL or the body into params_array",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"     ",
									"    params_array.sort();                    //lexicographically sort parameters by key",
									"    var encoded_params = \"\";               ",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"    }",
									"     ",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									"    // console.log(requestData);",
									" ",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    // console.log(\"prebase:\", prebase)",
									"     ",
									"    //encodes a string in base-64",
									"    var baseComplete = btoa(prebase);",
									"",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"// HMAC 2 - Get HMAC authentication header",
									"function getAuthHeader2(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.globals.get(\"parent_admin_api_ikey\"); //Auth or Admin API IKEY",
									"    var SKEY = pm.globals.get(\"parent_admin_api_skey\"); //Auth or Admin API SKEY",
									"    var API_HOSTNAME = pm.globals.get(\"parent_admin_api_host\"); //Auth or Admin API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"    // Check if the API hostname is defined. If not, throw an error.",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"     ",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Get the index of the start of the query parameters in the URL ",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"     ",
									"    // Clean up api_call by removing any unwanted characters",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"    // console.log('api_call:', api_call);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    //Create unsorted array of parameters from either URL or Body",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL",
									"    //(technically it looks like POST can be in the URL as well)",
									"",
									"    // Depending on the HTTP method and the existence of a request body,",
									"    // extract the query parameters from the URL or the body into params_array",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"     ",
									"    params_array.sort();                    //lexicographically sort parameters by key",
									"    var encoded_params = \"\";               ",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"    }",
									"     ",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									"    // console.log(requestData);",
									" ",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    // console.log(\"prebase:\", prebase)",
									"     ",
									"    //encodes a string in base-64",
									"    var baseComplete = btoa(prebase);",
									"",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"// HMAC 3 - Get HMAC authentication header",
									"function getAuthHeader3(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
									"    var AUTH_TYPE = 'HMAC-SHA1';",
									"",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"",
									"    if (Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"",
									"    params_array.sort();",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value, index, array) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Request 1 - Get Accounts",
									"function getAccounts() {",
									"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url1,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            if (responseJson.stat === \"OK\") {",
									"                // Populate DuoChildAccounts",
									"                responseJson.response.forEach(account => {",
									"                    DuoChildAccounts[account.account_id] = {",
									"                        name: account.name,",
									"                        apiHostname: account.api_hostname",
									"                    };",
									"                });",
									"",
									"                // Save the mapping object as a global variable",
									"                pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"",
									"                // Proceed to the next request",
									"                getSettings();",
									"            } else {",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 2 - Get Settings",
									"function getSettings() {",
									"    var url = `https://${pm.globals.get(\"parent_admin_api_host\")}/admin/v1/settings`;",
									"    pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            if (responseJson.stat === \"OK\") {",
									"                var name = responseJson.response.name;",
									"                pm.globals.set(\"parent_account_name\", name);",
									"",
									"                // Proceed to the next request",
									"                getAccountSummary();",
									"            } else {",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 3 - Get Account Summary",
									"function getAccountSummary() {",
									"    var url = `https://${pm.globals.get(\"parent_admin_api_host\")}/admin/v1/info/summary`;",
									"    pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            var userCount = responseJson.response.user_count;",
									"            var nfr_adjustment = pm.collectionVariables.get(\"nfr_adjustment\");",
									"            var adjustmentValue = nfr_adjustment ? parseInt(nfr_adjustment, 10) : 50;",
									"            var parentAccountUserCount = (userCount >= adjustmentValue) ? userCount - adjustmentValue : 0;",
									"            pm.globals.set(\"parent_account_user_count\", parentAccountUserCount.toString());",
									"",
									"            // Proceed to the next request",
									"            processAccounts();",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 4 - Get Edition for each account",
									"function processAccounts() {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"    var keys = Object.keys(DuoChildAccounts);",
									"    processAccount(keys, 0);",
									"    }",
									"",
									"    function processAccount(keys, index) {",
									"    if (index >= keys.length) {",
									"        // All accounts have been processed",
									"        pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"",
									"        // Now call getUserCounts",
									"        getUserCounts();",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    var accountDetails = DuoChildAccounts[accountId];",
									"    var apiHostname = accountDetails.apiHostname;",
									"",
									"    var urlWithAccountId = `https://${apiHostname}/admin/v1/billing/edition?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
									"    pm.globals.set(\"hmacAuthHeader3\", getAuthHeader3(\"GET\", urlWithAccountId, {}, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader3\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error('Request failed for account:', accountDetails.name, '; Error:', err);",
									"            processAccount(keys, index + 1); // Move to the next account in case of an error",
									"            return;",
									"        }",
									"",
									"        if (res.code === 200) {",
									"            var resJson = res.json();",
									"            var edition = resJson.response.edition;",
									"            DuoChildAccounts[accountId].edition = edition;",
									"",
									"            if (resJson.metadata && resJson.metadata.next_offset) {",
									"                pm.globals.set('next_offset', resJson.metadata.next_offset);",
									"                processAccount(keys, index); // Continue with the same account",
									"            } else {",
									"                pm.globals.set('next_offset', 0);",
									"                processAccount(keys, index + 1); // Move to the next account",
									"            }",
									"        } else {",
									"            console.error('Request failed for account:', accountDetails.name, '; Response:', res);",
									"            processAccount(keys, index + 1); // Move to the next account in case of an error",
									"        }",
									"    });",
									"}",
									"",
									"//Request 5 - Get User Count for each account",
									"function getUserCounts() {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"    var keys = Object.keys(DuoChildAccounts);",
									"    processUserCount(keys, 0);",
									"}",
									"",
									"function processUserCount(keys, index) {",
									"    if (index >= keys.length) {",
									"        // All accounts have been processed",
									"        pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    var accountDetails = DuoChildAccounts[accountId];",
									"    var apiHostname = accountDetails.apiHostname;",
									"",
									"    var urlWithAccountId = `https://${apiHostname}/admin/v1/info/summary?account_id=${accountId}`;",
									"    pm.globals.set(\"hmacAuthHeader3\", getAuthHeader3(\"GET\", urlWithAccountId, {}, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader3\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error fetching user count for account ID:\", accountId, \"; Error:\", err);",
									"            processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseData = JSON.parse(res.text());",
									"            if (responseData && responseData.stat === \"OK\") {",
									"                DuoChildAccounts[accountId].userCount = responseData.response.user_count;",
									"                processUserCount(keys, index + 1); // Move to the next account",
									"            } else {",
									"                console.log(\"Error: Response status is not OK for account ID:\", accountId);",
									"                processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing response body as JSON:\", error);",
									"            processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"        }",
									"    });",
									"}",
									"",
									"// Start the sequence",
									"getAccounts();",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						},
						"description": "Returns a list of child accounts."
					},
					"response": []
				}
			],
			"description": "**Cost Report:** The \"Cost Report\" comprises multiple request designed to provide a detailed breakdown of your current Duo usage, including the total number of users, the associated edition (Essentials, Advantage, Premier), and the corresponding costs. It provides both a console-friendly table and a CSV report of each client's Duo usage.\n\n- **Important Note**: _The Duo Admin API doesn't offer a method to retrieve the edition of the parent account natively, so to work aroud this, we have added a collection variable_ `parent_account_edition_`_that must be manually set to the edition of the parent account. It must be one of..._\n    - Duo Essentials\n    - Duo Advantage\n    - Duo Premier\n- Before starting, ensure that the edition name is spelled correctly in the collection variable. If an edition name is misspelled or missing, the function will not run successfully."
		},
		{
			"name": "Policy Management",
			"item": [
				{
					"name": "Update Global Policy",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variable Declaration",
									"var DuoChildAccounts = JSON.parse(pm.collectionVariables.get(\"duoChildAccounts\"));",
									"",
									"// Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"    var params_array = params_unsorted.split(\"&\");",
									"    params_array.sort();",
									"    var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var jsonDataString = JSON.stringify(requestBody);",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"var keys = Object.keys(DuoChildAccounts);",
									"processAccount(keys, 0);",
									"",
									"function processAccount(keys, index) {",
									"    if (index >= keys.length) {",
									"        console.log(\"All accounts have been processed\");",
									"",
									"        // Unset global variables after processing all accounts",
									"        pm.globals.unset(\"newChildAccount\");",
									"        pm.globals.unset(\"timestampHeader\");",
									"        pm.globals.unset(\"hmacAuthHeader\");",
									"",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    if (accountId && accountId.trim() !== \"\") {",
									"        var accountDetails = DuoChildAccounts[accountId];",
									"",
									"        if (!accountDetails) {",
									"            console.error('Account details not found for account ID:', accountId);",
									"            processAccount(keys, index + 1);",
									"            return;",
									"        }",
									"",
									"        var accountName = accountDetails.name;",
									"        var apiHostname = accountDetails.apiHostname;",
									"        var globalPolicyKey = accountDetails.globalPolicyKey;",
									"",
									"        if (!globalPolicyKey) {",
									"            console.error('Global policy key not found for account:', accountName);",
									"            processAccount(keys, index + 1);",
									"            return;",
									"        }",
									"",
									"        var urlWithAccountId = `https://${apiHostname}/admin/v2/policies/${globalPolicyKey}?account_id=${accountId}`;",
									"",
									"        // Fetching requestBody from the Pre-request Script or Tests script section of Postman",
									"        var requestBody = pm.request.body ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"PUT\", urlWithAccountId, requestBody, apiHostname));",
									"",
									"        pm.sendRequest({",
									"            url: urlWithAccountId,",
									"            method: \"PUT\",",
									"            header: {",
									"                \"Content-Type\": \"application/json\",",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"                \"Date\": pm.globals.get(\"timestampHeader\")",
									"            },",
									"            body: {",
									"                mode: 'raw',",
									"                raw: JSON.stringify(requestBody)",
									"            }",
									"        }, function (err, res) {",
									"            if (res.code === 200) {",
									"                console.log('Global policy updated for account:', accountName);",
									"            } else {",
									"                console.error('Request failed for account:', accountName, '; Error:', err, '; Response:', res);",
									"            }",
									"",
									"            processAccount(keys, index + 1);",
									"        });",
									"    } else {",
									"        console.error('Invalid account ID:', accountId);",
									"        processAccount(keys, index + 1);",
									"    }",
									"}",
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// const policyKey = pm.response.json().response.policy_key;",
									"// const policyName = pm.response.json().response.name;",
									"// pm.globals.set(\"temp_policy_key\", policyKey);",
									"// pm.globals.set(\"policyName\", policyName);",
									"// var ChildAccount= pm.globals.get(\"ChildAccount\", ChildAccount);",
									"// console.log(policyName + \" policy updated successfully for \" + ChildAccount);",
									"// // console.log(\"Policy key assigned to temp_policy_key: \" + policyKey);",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n            \"is_global_policy\": true,\n            \"sections\": {\n                \"authentication_methods\": {\n                    \"allowed_auth_list\": [\n                        \"duo-passcode\",\n                        \"duo-push\",\n                        \"hardware-token\",\n                        \"sms\",\n                        \"webauthn-platform\",\n                        \"webauthn-roaming\"\n                    ],\n                    \"auto_retry_sms\": false,\n                    \"blocked_auth_list\": [],\n                    \"require_verified_push\": true,\n                    \"verified_push_digits\": 6\n                }\n         }\n}"
						},
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "The request in this folder updates the global policy for each Duo child account using the list of account IDs in duoChildAccounts.\n\n1. **Update Policy Section Data:** Navigate to the Body tab of the 'Update Global Policy' request and modify the policy section data to align with your desired security policies. See [Policy Section Data](https://duo.com/docs/adminapi#policy-section-data)\n    \n2. **Update Global Policy :** Execute the Update Global Policy request. This process iterates over each ID in your duoChildAccounts, applying the newly configured global policy settings to all your Duo child accounts.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// Get HMAC 1",
							"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
							"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
							"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
							"",
							"    // Check if the API hostname is defined. If not, throw an error.",
							"    if (!API_HOSTNAME) {",
							"        throw new Error(\"API_HOSTNAME is not defined\");",
							"    }",
							"     ",
							"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
							"    if (requestUrl.indexOf(\"?\") == -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    // Get the index of the start of the query parameters in the URL ",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"",
							"    // Calculate the length of the hostname",
							"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
							"",
							"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
							"     ",
							"    // Clean up api_call by removing any unwanted characters",
							"    api_call = api_call.replace(\"}}\", \"\");",
							"    // console.log('api_call:', api_call);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"    //Create unsorted array of parameters from either URL or Body",
							"    //Assuming POST parameters are in the Body, GET paramters are in URL",
							"    //(technically it looks like POST can be in the URL as well)",
							"",
							"    // Depending on the HTTP method and the existence of a request body,",
							"    // extract the query parameters from the URL or the body into params_array",
							"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
							"        for (var parameter1 in requestBody) {",
							"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart+1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"     ",
							"    params_array.sort();                    //lexicographically sort parameters by key",
							"    var encoded_params = \"\";               ",
							"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
							"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
							"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
							"    }",
							"     ",
							"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\",timestamp);",
							" ",
							"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
							"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
							"    // console.log(requestData);",
							" ",
							"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
							"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
							"     ",
							"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
							"    var prebase = IKEY+\":\"+ hmacDigest;",
							"    // console.log(\"prebase:\", prebase)",
							"     ",
							"    //encodes a string in base-64",
							"    var baseComplete = btoa(prebase);",
							"",
							"    var authHeader = \"Basic \"+ baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"// Get HMAC 2",
							"function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
							"",
							"    if (requestUrl.indexOf(\"?\") === -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"",
							"    // Check if requestBody is not empty",
							"    if (Object.keys(requestBody).length !== 0) {",
							"        var jsonDataString = JSON.stringify(requestBody);",
							"        jsonDataString = replaceAllVariables(jsonDataString);",
							"        requestBody = JSON.parse(jsonDataString);",
							"        for (var parameter in requestBody) {",
							"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart + 1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"",
							"    params_array.sort();",
							"    var encoded_params = \"\";",
							"    if (params_array[0] !== \"\") {",
							"        var encoded_params_array = params_array.map(urlEncodeParams);",
							"        encoded_params = encoded_params_array.join(\"&\");",
							"    }",
							"",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\", timestamp);",
							"",
							"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
							"    if (Object.keys(requestBody).length !== 0) {",
							"        requestData += \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
							"    } else {",
							"        requestData += \"\\n\" + CryptoJS.SHA512(\"\") + \"\\n\" + CryptoJS.SHA512(\"\");",
							"    }",
							"",
							"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
							"",
							"    var prebase = IKEY + \":\" + hmacDigest;",
							"    var baseComplete = btoa(prebase);",
							"    var authHeader = \"Basic \" + baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"function urlEncodeParams(value, index, array) {",
							"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
							"}",
							"",
							"function replaceAllVariables(str) {",
							"    var variableRegex = /\\{\\{(\\w+)\\}\\}/g;",
							"    return str.replace(variableRegex, function(match, variableName) {",
							"        return pm.variables.get(variableName);",
							"    });",
							"}",
							"",
							"// Request 1 - Get Accounts",
							"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
							"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
							"",
							"    pm.sendRequest({",
							"    url: url1,",
							"    method: \"POST\",",
							"    header: {",
							"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"        \"Date\": pm.globals.get(\"timestampHeader\")",
							"    },",
							"    body: {}",
							"    }, function(err, res) {",
							"    if (err) {",
							"        console.log(\"Error:\", err);",
							"        return;",
							"    }",
							"",
							"    try {",
							"        var responseJson = JSON.parse(res.text());",
							"        if (responseJson.stat === \"OK\") {",
							"            var duoChildAccounts = {};",
							"            responseJson.response.forEach(function(account) {",
							"                duoChildAccounts[account.account_id] = {",
							"                    name: account.name,",
							"                    apiHostname: account.api_hostname",
							"                };",
							"            });",
							"",
							"            pm.collectionVariables.set(\"duoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"",
							"            // Now that duoChildAccounts is set, start processing each account",
							"            var keys = Object.keys(duoChildAccounts);",
							"            processAccount(keys, 0, duoChildAccounts);",
							"        } else {",
							"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
							"        }",
							"    } catch (error) {",
							"        console.log(\"Error parsing JSON:\", error);",
							"    }",
							"});",
							"",
							"function processAccount(keys, index, DuoChildAccounts) {",
							"    if (index >= keys.length) {",
							"        // console.log(\"All accounts have been processed\");",
							"",
							"        // Remove the specified variables",
							"        pm.globals.unset(\"timestampHeader\");",
							"        pm.globals.unset(\"hmacAuthHeader\");",
							"        pm.globals.unset(\"next_offset\");",
							"        return;",
							"    }",
							"",
							"    let accountId = keys[index];",
							"    if (accountId && accountId.trim() !== \"\" && DuoChildAccounts[accountId]) {",
							"        var accountDetails = DuoChildAccounts[accountId];",
							"        var accountName = accountDetails.name;",
							"        var apiHostname = accountDetails.apiHostname;",
							"",
							"        var urlWithAccountId = `https://${apiHostname}/admin/v2/policies?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
							"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"GET\", urlWithAccountId, {}, apiHostname));",
							"",
							"        pm.sendRequest({",
							"            url: urlWithAccountId,",
							"            method: \"GET\",",
							"            header: {",
							"                \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"                \"Date\": pm.globals.get(\"timestampHeader\")",
							"            },",
							"            body: {}",
							"        }, function(err, res) {",
							"            if (err) {",
							"                console.error('Error for account:', accountName, '; Error:', err);",
							"                processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account in case of an error",
							"                return;",
							"            }",
							"",
							"            if (res.code === 200) {",
							"                var resJson = res.json();",
							"                var policies = resJson.response || [];",
							"",
							"                var globalPolicy = policies.find(policy => policy.is_global_policy);",
							"                if (globalPolicy) {",
							"                    DuoChildAccounts[accountId].globalPolicyKey = globalPolicy.policy_key;",
							"                    pm.collectionVariables.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
							"                }",
							"",
							"                if (resJson.metadata && resJson.metadata.next_offset) {",
							"                    pm.globals.set('next_offset', resJson.metadata.next_offset);",
							"                    processAccount(keys, index, DuoChildAccounts); // Continue with the same account",
							"                } else {",
							"                    pm.globals.set('next_offset', 0);",
							"                    processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account",
							"                }",
							"            } else {",
							"                console.error('Request failed for account:', accountName, '; Response:', res);",
							"                processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account in case of a failed request",
							"            }",
							"        });",
							"    } else {",
							"        console.error('Invalid or missing account details for accountId:', accountId);",
							"        processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account if current is invalid",
							"    }",
							"}",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							"// // Parse the response as JSON",
							"// var responseJson = pm.response.json();",
							"",
							"// // Extract the account IDs and account names, and store them in arrays",
							"// var accountIds = [];",
							"// var accountNames = [];",
							"// var duoChildAccounts = {};",
							"",
							"// for (var i = 0; i < responseJson.response.length; i++) {",
							"//   var accountId = responseJson.response[i].account_id;",
							"//   var accountName = responseJson.response[i].name;",
							"  ",
							"//   accountIds.push(accountId);",
							"//   accountNames.push(accountName);",
							"  ",
							"//   duoChildAccounts[accountId] = accountName;",
							"// }",
							"",
							"// pm.globals.set(\"ChildAccountIds\", JSON.stringify(accountIds));",
							"// pm.globals.set(\"ChildAccountNames\", JSON.stringify(accountNames));",
							"",
							"// // Save the mapping object as a global variable",
							"// pm.globals.set(\"DuoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"",
							"// var accountIds = JSON.parse(pm.globals.get(\"ChildAccountIds\"));",
							"// var totalAccounts = accountIds.length;",
							"// var statusCode = responseJson.stat;"
						]
					}
				}
			]
		},
		{
			"name": "Push Phish Simulator",
			"item": [
				{
					"name": "Create Auth API [Push Phish]",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Checks for an existing entry in child_auth_api_matrix",
									"function checkAndUpdateForExistingAccount() {",
									"    const accountName = pm.collectionVariables.get(\"child_account_name\");",
									"    const currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"    ",
									"    if (currentMatrix) {",
									"        const matrixArray = JSON.parse(currentMatrix);",
									"        const existingEntry = matrixArray.find(entry => entry.accountName === accountName);",
									"        ",
									"        if (existingEntry) {",
									"            // Update collection variables with the details from the existing entry",
									"            pm.collectionVariables.set(\"child_account_account_id\", existingEntry.accountId);",
									"            pm.collectionVariables.set(\"child_auth_api_ikey\", existingEntry.integrationKey);",
									"            pm.collectionVariables.set(\"child_auth_api_skey\", existingEntry.secretKey);",
									"            pm.collectionVariables.set(\"child_auth_api_host\", existingEntry.apiHostname);",
									"            ",
									"       var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"        console.log(`Auth API [Push Phish] already exists on ${childAccountName} and is available for use.`);",
									"            return true;",
									"        }",
									"    }",
									"    // Return false if no existing entry was found",
									"    return false;",
									"}",
									"",
									"// If found, updates collection variables with the associated request credentials",
									"if (checkAndUpdateForExistingAccount()) {} else {",
									"   ",
									"//HMAC 1",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); ",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); ",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); ",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"    // Check if the API hostname is defined. If not, throw an error.",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"     ",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Get the index of the start of the query parameters in the URL ",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"     ",
									"    // Clean up api_call by removing any unwanted characters",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"    // console.log('api_call:', api_call);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    //Create unsorted array of parameters from either URL or Body",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL",
									"    //(technically it looks like POST can be in the URL as well)",
									"",
									"    // Depending on the HTTP method and the existence of a request body,",
									"    // extract the query parameters from the URL or the body into params_array",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"     ",
									"    params_array.sort();                    //lexicographically sort parameters by key",
									"    var encoded_params = \"\";               ",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"    }",
									"     ",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									"    // console.log(requestData);",
									" ",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    // console.log(\"prebase:\", prebase)",
									"     ",
									"    //encodes a string in base-64",
									"    var baseComplete = btoa(prebase);",
									"",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"// HMAC 2",
									"function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"    var params_array = params_unsorted.split(\"&\");",
									"    params_array.sort();",
									"    var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var jsonDataString = JSON.stringify(requestBody);",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Request 1 - Get Accounts",
									"function getAccounts() {",
									"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url1,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        var responseJson = JSON.parse(res.text());",
									"        if (responseJson.stat === \"OK\") {",
									"            // Logic to set child_account_account_id and child_auth_api_host",
									"            handleGetAccountsResponse(responseJson);",
									"        } else {",
									"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"        }",
									"    });",
									"}",
									"",
									"// Handler for Get Accounts response",
									"function handleGetAccountsResponse(responseJson) {",
									"    // Extract relevant data from responseJson and set collection variables",
									"    var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"    var foundAccount = responseJson.response.find(acc => acc.name === childAccountName);",
									"",
									"    if (foundAccount) {",
									"        pm.collectionVariables.set(\"child_account_account_id\", foundAccount.account_id);",
									"        pm.collectionVariables.set(\"child_auth_api_host\", foundAccount.api_hostname);",
									"     ",
									"",
									"        // Proceed with Request 2 - Create Integration",
									"        createIntegration(foundAccount.api_hostname, foundAccount.account_id);",
									"    } else {",
									"        console.log(`No matching account found for ${childAccountName}.`);",
									"    }",
									"}",
									"",
									"// Request 2 - Create Integration",
									"function createIntegration(apiHostname, accountId) {",
									"    var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"    ",
									"    // Ensure accountId is available",
									"    if (!accountId) {",
									"        console.log(\"Account ID is not set. Stopping execution.\");",
									"        return;",
									"    }",
									"",
									"    // Pre-check for existing integration in child_auth_api_matrix",
									"    var currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"    currentMatrix = currentMatrix ? JSON.parse(currentMatrix) : [];",
									"    var existingEntry = currentMatrix.find(entry => entry.accountName === childAccountName && entry.accountId === accountId);",
									"",
									"    if (existingEntry) {",
									"        console.log(`Duo Auth API [Push Phish] already exists for ${childAccountName} and is available for use.`);",
									"        // Optionally, you can call retrieveSecretKey or any other function here if needed.",
									"        return;",
									"    }",
									"",
									"    var urlWithAccountId = `https://${apiHostname}/admin/v2/integrations?account_id=${accountId}`;",
									"    var requestBody = {",
									"        \"name\": \"Auth API [Push Phish]\",",
									"        \"type\": \"authapi\"",
									"    };",
									"",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"POST\", urlWithAccountId, requestBody, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/json\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {",
									"            mode: 'raw',",
									"            raw: JSON.stringify(requestBody)",
									"        }",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error('Network error:', err);",
									"            return;",
									"        }",
									"        var responseData = res.json();",
									"        if (res.code === 200) {",
									"            var integrationKey = responseData.response.integration_key;",
									"            pm.collectionVariables.set(\"child_auth_api_ikey\", integrationKey);",
									"          ",
									"",
									"            // Update matrix and proceed to retrieve the secret key",
									"            // updateMatrix(accountId, childAccountName, integrationKey, pm.collectionVariables.get(\"child_auth_api_skey\"), apiHostname);",
									"            ",
									"            retrieveSecretKey(apiHostname, integrationKey, accountId);",
									"        } else {",
									"            console.error(`Request 2 failed. HTTP status code: ${res.code}; Response:`, responseData);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 3 - Retrieve Secret Key",
									"function retrieveSecretKey(apiHostname, integrationKey, accountId) {",
									"    // Retrieve childAccountName within this function to ensure it's defined",
									"    var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"    if (!accountId) {",
									"        console.log(\"Account ID is not provided. Stopping execution.\");",
									"        return;",
									"    }",
									"    if (!childAccountName) {",
									"        console.log(\"Child Account Name is not provided. Stopping execution.\");",
									"        return;",
									"    }",
									"",
									"    var urlWithAccountId2 = `https://${apiHostname}/admin/v1/integrations/${integrationKey}/skey?account_id=${accountId}`;",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"GET\", urlWithAccountId2, {}, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId2,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/json\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {",
									"            mode: 'raw',",
									"            raw: JSON.stringify({})",
									"        }",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error('Network error on the second request:', err);",
									"        } else {",
									"            var responseData = res.json();",
									"            if (res.code === 200) {",
									"                var secretKey = responseData.response.secret_key;",
									"                pm.collectionVariables.set(\"child_auth_api_skey\", secretKey);",
									"                updateMatrix(accountId, childAccountName, integrationKey, secretKey, apiHostname);",
									"                console.log(`Auth API [Push Phish] created successfully on ${childAccountName} and is available for use.`);",
									"            } else {",
									"                console.error(`Second request failed. Response code: ${res.code}; Response:`, responseData);",
									"            }",
									"        }",
									"    });",
									"}",
									"",
									"function updateMatrix(accountId, childAccountName, integrationKey, secretKey, apiHostname) {",
									"    var currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"    currentMatrix = currentMatrix ? JSON.parse(currentMatrix) : [];",
									"    currentMatrix.push({",
									"        accountId: accountId,",
									"        accountName: childAccountName,",
									"        integrationKey: integrationKey,",
									"        secretKey: secretKey,",
									"        apiHostname: apiHostname",
									"    });",
									"    pm.collectionVariables.set(\"child_auth_api_matrix\", JSON.stringify(currentMatrix));",
									"}",
									"",
									"// Make sure getAccounts function is defined somewhere above this snippet",
									"getAccounts();",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Retrieve Push Phish Users",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
									"    var AUTH_TYPE = 'HMAC-SHA1';",
									"",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"",
									"    if (Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"",
									"    params_array.sort();",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value, index, array) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Replace duoChildAccounts and processAccount function with direct request",
									"var apiHostname = pm.collectionVariables.get(\"child_auth_api_host\"); // Get the apiHostname from the collection variable",
									"var accountId = pm.collectionVariables.get(\"child_account_account_id\"); // Get the accountId from the collection variable",
									"",
									"// Update the URL to use the specific apiHostname and accountId",
									"var urlWithAccountId = `https://${apiHostname}/admin/v1/users?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
									"",
									"// Generate the HMAC header using the specific apiHostname",
									"var hmacAuthHeader = getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname);",
									"",
									"pm.sendRequest({",
									"    url: urlWithAccountId,",
									"    method: \"GET\",",
									"    header: {",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"        \"Authorization\": hmacAuthHeader,",
									"        \"Date\": pm.globals.get(\"timestampHeader\")",
									"    },",
									"    body: {}",
									"}, function(err, res) {",
									"    if (err) {",
									"        console.error('Request failed; Error:', err);",
									"    } else {",
									"        // console.log('Request successful; Response:', res.json());",
									"",
									"        // Process the response to filter users part of the group specified in the \"pushPhishGroup\" collection variable and format them in CSV",
									"        let response = res.json();",
									"        let users = response.response;",
									"        let groupName = pm.collectionVariables.get(\"pushPhishGroup\"); // Retrieve the group name from collection variable",
									"        let pushUsersCsv = 'username\\n'; // CSV header",
									"",
									"        users.forEach(user => {",
									"            let groups = user.groups;",
									"            let isMemberOfSpecifiedGroup = groups.some(group => group.name === groupName);",
									"",
									"            if (isMemberOfSpecifiedGroup) {",
									"                pushUsersCsv += `${user.username}\\n`; // Add username to CSV string",
									"            }",
									"        });",
									"",
									"        // Update the collection variable with CSV data",
									"        pm.collectionVariables.set(\"pushPhishusersCsv\", pushUsersCsv);",
									"        console.log(`Updated pushPhishusersCsv collection variable with users from ${groupName} group`);",
									"    }",
									"});",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Execute Push Phish",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// // Parse the JSON response",
									"// const jsonResponse = pm.response.json();",
									"",
									"// // Check if the \"stat\" value is \"OK\"",
									"// if (jsonResponse.stat === \"OK\") {",
									"//     // Log a message in the console",
									"//     console.log(\"Successfully performed second-factor authentication for specified useror sent the user a new batch of passcodes via SMS.\");",
									"// } else {",
									"//     console.log(\"Invalid or missing parameters. Verify all the set parameters are correct for the user.\");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.collectionVariables.get(\"child_auth_api_ikey\"); // Use Auth API IKEY",
									"    var SKEY = pm.collectionVariables.get(\"child_auth_api_skey\"); // Use Auth API SKEY",
									"    var API_HOSTNAME = pm.collectionVariables.get(\"child_auth_api_host\"); // Use Auth API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA512'; // Authentication type, though not directly used in the code, denotes the algorithm for HMAC",
									"",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart).replace(\"}}\", \"\");",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter in requestBody) {",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"    params_array.sort();",
									"    ",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + API_HOSTNAME + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"",
									"pm.collectionVariables.set(\"phish_auth_status\", JSON.stringify([]));",
									"",
									"",
									"// Retrieve the pushPhishusersCsv variable and split it into an array of usernames",
									"var users = pm.collectionVariables.get(\"pushPhishusersCsv\").split(\"\\n\");",
									"",
									"users.slice(1).forEach(function(user) {",
									"    if (user.trim() === \"\") return; // Skip empty lines or invalid usernames",
									"",
									"    var url = `https://${pm.collectionVariables.get(\"child_auth_api_host\")}/auth/v2/auth?username=${user.trim()}&factor=auto&device=auto&async=1`;",
									"",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url, {}));",
									"",
									"    pm.sendRequest({",
									"    url: url,",
									"    method: \"POST\",",
									"    header: {",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"        \"Date\": pm.globals.get(\"timestampHeader\")",
									"    },",
									"    body: {}",
									"    }, function(err, res) {",
									"    if (err) {",
									"        console.error('Request failed; Error:', err);",
									"    } else {",
									"        let response = res.json(); // Parse the JSON response",
									"        // Assuming response contains the required txid and stat OK",
									"        if (response.stat === \"OK\" && response.response && response.response.txid) {",
									"            // Retrieve the existing phish_auth_status or initialize if not present",
									"            let phishAuthStatus = JSON.parse(pm.collectionVariables.get(\"phish_auth_status\") || \"[]\");",
									"            // Add the current user and txid to the array",
									"            phishAuthStatus.push({ username: user.trim(), txid: response.response.txid });",
									"            // Update the collection variable with the new array",
									"            pm.collectionVariables.set(\"phish_auth_status\", JSON.stringify(phishAuthStatus));",
									"            console.log(`Push phish sent successfully to ${user.trim()}`);",
									"        }",
									"    }",
									"    });",
									"})"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "ipaddr",
									"value": "",
									"description": "Optional: The IP address of the user to be authenticated, in dotted quad format. This will cause an \"allow\" response to be sent if appropriate for requests from a trusted network.",
									"disabled": true
								},
								{
									"key": "hostname",
									"value": "",
									"description": "Optional: The host name of the device accessing the application.",
									"disabled": true
								},
								{
									"key": "async",
									"value": "",
									"description": "Optional: If this parameter is not provided, then the /auth endpoint will only return a response when the authentication process has completed. If, however, your application provides this parameter with a value of \"1\", then /auth will immediately return a transaction ID, and your application will need to subsequently query the /auth_status endpoint to get the status (and, eventually, result) of the authentication process.\n\nIf you enable async, then your application will be able to retrieve real-time status updates from the authentication process, rather than receiving no information until the process is complete.",
									"disabled": true
								},
								{
									"key": "type",
									"value": "",
									"description": "DUO PUSH - Optional: This string is displayed in the Duo Mobile app push notification and UI. You may wish to specify some alternate phrase for this parameter. The default English string in Duo Mobile v4 is \"Verify your identity\" and \"Are you logging in to\" followed by the application's name in the push request notification text, and \"Are you logging in to\" followed by the application's name in the request details screen as shown in Duo Mobile. With type specified, the notification text changes to \"Verify request\" and shows your customized string followed by a colon and the application's name, and the request details screen also shows your customized string and the application's name. Duo Mobile shows the equivalent localization in the languagues supported by the app, but does not attempt to localize your custom string or support multiple string values (for different languages).\n\nIn Duo Mobile v3, the default string shown is \"Login Request\" followed by the application's name in both the push notification text and on the request details screen.",
									"disabled": true
								},
								{
									"key": "display_username",
									"value": "",
									"description": "DUO PUSH - Optional: String to display in Duo Mobile in place of the user's Duo username.",
									"disabled": true
								},
								{
									"key": "pushinfo",
									"value": "",
									"description": "Optional: A set of URL-encoded key/value pairs with additional contextual information associated with this authentication attempt. The Duo Mobile app will display this information to the user.\n\nFor example: from=login%20portal&domain=example.com\n\nThe URL-encoded string's total length must be less than 20,000 bytes.",
									"disabled": true
								},
								{
									"key": "passcode",
									"value": "",
									"description": "PASSCODE - Required if using passcodes: Passcode entered by the user.",
									"disabled": true
								}
							]
						},
						"description": "TheÂ `/auth`Â endpoint performs second-factor authentication for a user by sending a push notification to the user's smartphone app, verifying a passcode, or placing a phone call. It is also used to send the user a new batch of passcodes via SMS."
					},
					"response": []
				},
				{
					"name": "Retreive Push Phish Report",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// // Parse the JSON response",
									"// const jsonResponse = pm.response.json();",
									"",
									"// // Check if the \"stat\" value is \"OK\"",
									"// if (jsonResponse.stat === \"OK\") {",
									"//     // Log a message in the console",
									"//     console.log(\"Successfully performed second-factor authentication for specified useror sent the user a new batch of passcodes via SMS.\");",
									"// } else {",
									"//     console.log(\"Invalid or missing parameters. Verify all the set parameters are correct for the user.\");"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.collectionVariables.get(\"child_auth_api_ikey\"); // Use Auth API IKEY",
									"    var SKEY = pm.collectionVariables.get(\"child_auth_api_skey\"); // Use Auth API SKEY",
									"    var API_HOSTNAME = pm.collectionVariables.get(\"child_auth_api_host\"); // Use Auth API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA512'; // Authentication type, though not directly used in the code, denotes the algorithm for HMAC",
									"",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart).replace(\"}}\", \"\");",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter in requestBody) {",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"    params_array.sort();",
									"    ",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + API_HOSTNAME + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"var pushAuthStatus = JSON.parse(pm.collectionVariables.get(\"phish_auth_status\"));",
									"",
									"// Initialize a structure to hold all user authentication details",
									"let authDetails = [];",
									"",
									"pushAuthStatus.forEach(function(authStatus, index, array) {",
									"    var url = `https://${pm.collectionVariables.get(\"child_auth_api_host\")}/auth/v2/auth_status?txid=${authStatus.txid}`;",
									"",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"     }, function(err, res) {",
									"        if (err) {",
									"            console.error(`Error for txid: ${authStatus.txid}`, err);",
									"            // Add error info to authDetails for reporting",
									"            authDetails.push({",
									"                username: authStatus.username,",
									"                result: \"Error\",",
									"                status: \"N/A\",",
									"                statusMsg: err.message || \"Unknown error\"",
									"            });",
									"        } else {",
									"            let response = res.json();",
									"            if (response.stat === \"OK\") {",
									"                // Add successful auth info to authDetails for reporting",
									"                authDetails.push({",
									"                    username: authStatus.username,",
									"                    result: response.response.result,",
									"                    status: response.response.status,",
									"                    statusMsg: response.response.status_msg",
									"                });",
									"            }",
									"        }",
									"",
									"        // If it's the last response, generate and log the CSV",
									"        if (index === array.length - 1) {",
									"            generateAndLogCsv(authDetails);",
									"        }",
									"    });",
									"});",
									"",
									"function generateAndLogCsv(authDetails) {",
									"    let csvContent = \"Username,Result,Status,Status Message\\n\"; // CSV header",
									"    authDetails.forEach(detail => {",
									"        csvContent += `${detail.username},${detail.result},${detail.status},${detail.statusMsg}\\n`;",
									"    });",
									"    console.log(csvContent);",
									"}",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "ipaddr",
									"value": "",
									"description": "Optional: The IP address of the user to be authenticated, in dotted quad format. This will cause an \"allow\" response to be sent if appropriate for requests from a trusted network.",
									"disabled": true
								},
								{
									"key": "hostname",
									"value": "",
									"description": "Optional: The host name of the device accessing the application.",
									"disabled": true
								},
								{
									"key": "async",
									"value": "",
									"description": "Optional: If this parameter is not provided, then the /auth endpoint will only return a response when the authentication process has completed. If, however, your application provides this parameter with a value of \"1\", then /auth will immediately return a transaction ID, and your application will need to subsequently query the /auth_status endpoint to get the status (and, eventually, result) of the authentication process.\n\nIf you enable async, then your application will be able to retrieve real-time status updates from the authentication process, rather than receiving no information until the process is complete.",
									"disabled": true
								},
								{
									"key": "type",
									"value": "",
									"description": "DUO PUSH - Optional: This string is displayed in the Duo Mobile app push notification and UI. You may wish to specify some alternate phrase for this parameter. The default English string in Duo Mobile v4 is \"Verify your identity\" and \"Are you logging in to\" followed by the application's name in the push request notification text, and \"Are you logging in to\" followed by the application's name in the request details screen as shown in Duo Mobile. With type specified, the notification text changes to \"Verify request\" and shows your customized string followed by a colon and the application's name, and the request details screen also shows your customized string and the application's name. Duo Mobile shows the equivalent localization in the languagues supported by the app, but does not attempt to localize your custom string or support multiple string values (for different languages).\n\nIn Duo Mobile v3, the default string shown is \"Login Request\" followed by the application's name in both the push notification text and on the request details screen.",
									"disabled": true
								},
								{
									"key": "display_username",
									"value": "",
									"description": "DUO PUSH - Optional: String to display in Duo Mobile in place of the user's Duo username.",
									"disabled": true
								},
								{
									"key": "pushinfo",
									"value": "",
									"description": "Optional: A set of URL-encoded key/value pairs with additional contextual information associated with this authentication attempt. The Duo Mobile app will display this information to the user.\n\nFor example: from=login%20portal&domain=example.com\n\nThe URL-encoded string's total length must be less than 20,000 bytes.",
									"disabled": true
								},
								{
									"key": "passcode",
									"value": "",
									"description": "PASSCODE - Required if using passcodes: Passcode entered by the user.",
									"disabled": true
								}
							]
						},
						"description": "TheÂ `/auth`Â endpoint performs second-factor authentication for a user by sending a push notification to the user's smartphone app, verifying a passcode, or placing a phone call. It is also used to send the user a new batch of passcodes via SMS."
					},
					"response": []
				},
				{
					"name": "Clear Push Phish Variables",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Clear the values of the collection variables",
									"pm.collectionVariables.set(\"pushPhishGroup\", \"\");",
									"pm.collectionVariables.unset(\"child_auth_api_ikey\");",
									"pm.collectionVariables.unset(\"child_auth_api_skey\");",
									"pm.collectionVariables.unset(\"child_auth_api_host\");",
									"pm.collectionVariables.unset(\"pushPhishusersCsv\");",
									"pm.collectionVariables.unset(\"duoChildAccounts\");",
									"pm.collectionVariables.unset(\"phish_auth_status\");",
									"pm.collectionVariables.unset(\"child_account_account_id\");",
									"pm.collectionVariables.set(\"child_account_name\", \"\");",
									"",
									"// Log a message to confirm the action, specifically formatted as requested",
									"console.log(`Cleared Push Phish collection variables.`);",
									"",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "This folder contains requests to run a Push Phishing simulation, allowing Administrators to determine if users understand the importance of only approving authorized Duo Push request.\n\n1. **Set Child Account Name:** Go to the Variables tab in Duo Administrative Tasks and enter the child account name in the `child_account_name` variable.\n    \n2. **Specify Group:** Create or select a group for the test users. Update the `pushPhishGroup` variable with the group name.**dfsdfdRun Requests:** Execute the requests in sequence, starting from \"Create Auth API\" to \"Execute Push Phish.\"\n    \n3. **Run Requests:** Execute the requests in sequence, starting from \"Create Auth API\" to \"Execute Push Phish.\"\n    \n\nWait about 60 seconds before proceeding to the next step, allowing the requests to be processed.\n\n1. **Retrieve Report:** Use \"Retrieve Push Phish Report\" to get a report detailing the authentication status of each user, showing who approved the request.\n    \n2. **Clear Variables:** Finish by running \"Clear Push Phish Variables\" to reset the values used during the simulation."
		},
		{
			"name": "Universal Prompt",
			"item": [
				{
					"name": "Retrieve V4 Integrations (V2)",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variable Declaration\r",
									"var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
									"\r",
									"// Get HMAC authentication header\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") === -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    // Check if requestBody is not empty\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        var jsonDataString = JSON.stringify(requestBody);\r",
									"        jsonDataString = replaceAllVariables(jsonDataString);\r",
									"        requestBody = JSON.parse(jsonDataString);\r",
									"        for (var parameter in requestBody) {\r",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        requestData += \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");\r",
									"    } else {\r",
									"        requestData += \"\\n\" + CryptoJS.SHA512(\"\") + \"\\n\" + CryptoJS.SHA512(\"\");\r",
									"    }\r",
									"\r",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);\r",
									"\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var baseComplete = btoa(prebase);\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"function replaceAllVariables(str) {\r",
									"    var variableRegex = /\\{\\{(\\w+)\\}\\}/g;\r",
									"    return str.replace(variableRegex, function(match, variableName) {\r",
									"        return pm.variables.get(variableName);\r",
									"    });\r",
									"}\r",
									"\r",
									"var keys = Object.keys(DuoChildAccounts);\r",
									"processAccount(keys, 0);\r",
									"\r",
									"// Before the processAccount function declaration\r",
									"var universal_prompt_ikeys = {};\r",
									"\r",
									"\r",
									"function processAccount(keys, index) {\r",
									"    if (index >= keys.length) {\r",
									"        // All accounts have been processed\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    let accountId = keys[index];\r",
									"    if (accountId && accountId.trim() !== \"\") {\r",
									"        pm.globals.set(\"accountId\", accountId);\r",
									"        var accountDetails = DuoChildAccounts[accountId];\r",
									"        var accountName = accountDetails.name;\r",
									"        var apiHostname = accountDetails.apiHostname; // Get the apiHostname for the current account\r",
									"\r",
									"        // Update the URL to use the specific apiHostname\r",
									"        var urlWithAccountId = `https://${apiHostname}/admin/v2/integrations?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;\r",
									"\r",
									"        // Generate the HMAC header using the specific apiHostname\r",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname));\r",
									"\r",
									"        pm.sendRequest({\r",
									"    url: urlWithAccountId,\r",
									"    method: \"GET\",\r",
									"    header: {\r",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
									"        \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"    },\r",
									"    body: {}\r",
									"}, function(err, res) {\r",
									"    if (res.code === 200) {\r",
									"        var resJson = res.json();\r",
									"        var users = resJson.response || [];\r",
									"\r",
									"        users.forEach(function(integration) {\r",
									"            if (integration.frameless_auth_prompt_enabled === 1 && integration.type !== 'sso-generic') {\r",
									"                // Check if the account entry is already created, if not initialize it\r",
									"                if (!universal_prompt_ikeys[accountId]) {\r",
									"                    universal_prompt_ikeys[accountId] = {\r",
									"                        accountName: accountName,\r",
									"                        apiHostname: apiHostname, // Store the API hostname here\r",
									"                        integrationKeys: []\r",
									"                    };\r",
									"                }\r",
									"                // No need to check for duplicate integration keys as we assume they are unique per account\r",
									"                universal_prompt_ikeys[accountId].integrationKeys.push(integration.integration_key);\r",
									"            }\r",
									"        });\r",
									"\r",
									"         pm.collectionVariables.set(\"universal_prompt_ikeys\", JSON.stringify(universal_prompt_ikeys));\r",
									"\r",
									"        if (resJson.metadata && resJson.metadata.next_offset) {\r",
									"            pm.globals.set('next_offset', resJson.metadata.next_offset);\r",
									"            processAccount(keys, index);\r",
									"        } else {\r",
									"            pm.globals.set('next_offset', 0);\r",
									"            processAccount(keys, index + 1);\r",
									"        }\r",
									"    } else {\r",
									"        console.error('Request failed for account:', accountName, '; Error:', err, '; Response:', res);\r",
									"        processAccount(keys, index + 1);\r",
									"    }\r",
									"}); // Correctly closes the pm.sendRequest call\r",
									"} // Correctly closes the if (accountId && accountId.trim() !== \"\") block\r",
									"} // Correctly closes the processAccount function"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.globals.unset(\"timestampHeader\");",
									"    pm.globals.unset(\"hmacAuthHeader\");",
									"    pm.globals.unset(\"accountId\");",
									"    pm.globals.unset(\"next_offset\");"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded",
								"type": "text"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}",
								"type": "text"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				},
				{
					"name": "Enable Universal Prompt",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"    var params_array = params_unsorted.split(\"&\");",
									"    params_array.sort();",
									"    var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var jsonDataString = JSON.stringify(requestBody);",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"function updateIntegrationsForAllAccounts() {",
									"    const universalPromptIkeysStr = pm.collectionVariables.get(\"universal_prompt_ikeys\");",
									"    if (!universalPromptIkeysStr) {",
									"        console.log(\"No universal_prompt_ikeys found. Exiting.\");",
									"        return;",
									"    }",
									"    const universalPromptIkeys = JSON.parse(universalPromptIkeysStr);",
									"",
									"    Object.keys(universalPromptIkeys).forEach(accountId => {",
									"        const accountInfo = universalPromptIkeys[accountId];",
									"        const accountName = accountInfo.accountName; // Assuming account name is needed for logging or other purposes",
									"        const integrationKeys = accountInfo.integrationKeys;",
									"        const apiHostname = accountInfo.apiHostname; // Retrieve the apiHostname for each account from universal_prompt_ikeys",
									"",
									"        integrationKeys.forEach(integrationKey => {",
									"            createOrUpdateIntegration(apiHostname, accountId, integrationKey);",
									"        });",
									"    });",
									"}",
									"",
									"function createOrUpdateIntegration(apiHostname, accountId, integrationKey) {",
									"    const url = `https://${apiHostname}/admin/v2/integrations/${integrationKey}?account_id=${accountId}`;",
									"    const requestBody = {",
									"        \"prompt_v4_enabled\": 1",
									"    };",
									"",
									"    const authHeader = getAuthHeader(\"POST\", url, requestBody, apiHostname);",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/json\",",
									"            \"Authorization\": authHeader,",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {",
									"            mode: 'raw',",
									"            raw: JSON.stringify(requestBody)",
									"        }",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error(`Network error for account ${accountId} and integration ${integrationKey}:`, err);",
									"            return;",
									"        }",
									"        if (res.code === 200 || res.code === 201) {",
									"            console.log(`Integration updated for account ${accountId} and integration ${integrationKey}`);",
									"        } else {",
									"            console.error(`Request failed for account ${accountId} and integration ${integrationKey}. HTTP status code: ${res.code}; Response:`, res.json());",
									"        }",
									"    });",
									"}",
									"",
									"// Trigger the update process",
									"updateIntegrationsForAllAccounts();",
									"pm.collectionVariables.unset(\"universal_prompt_ikeys\");"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "The requests in this folder automates the updating of in scope applications to the Universal Prompt across the full list of child accounts.\n\nIt involves two key steps:\n\n1. **Retrieve V4 Integrations**: This step iterates over the list child account IDs to identify and collect applications eligible for the Universal Prompt update. These applications are stored in a variable (universal_prompt_ikeys), mapped by account ID, account name, and integration keys.\n    \n2. **Enable Universal Prompt**: The next step takes the identified integration keys and activates the Universal Prompt for these applications.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
							"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
							"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
							"",
							"    // Check if the API hostname is defined. If not, throw an error.",
							"    if (!API_HOSTNAME) {",
							"        throw new Error(\"API_HOSTNAME is not defined\");",
							"    }",
							"     ",
							"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
							"    if (requestUrl.indexOf(\"?\") == -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    // Get the index of the start of the query parameters in the URL ",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"",
							"    // Calculate the length of the hostname",
							"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
							"",
							"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
							"     ",
							"    // Clean up api_call by removing any unwanted characters",
							"    api_call = api_call.replace(\"}}\", \"\");",
							"    // console.log('api_call:', api_call);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"    //Create unsorted array of parameters from either URL or Body",
							"    //Assuming POST parameters are in the Body, GET paramters are in URL",
							"    //(technically it looks like POST can be in the URL as well)",
							"",
							"    // Depending on the HTTP method and the existence of a request body,",
							"    // extract the query parameters from the URL or the body into params_array",
							"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
							"        for (var parameter1 in requestBody) {",
							"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart+1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"     ",
							"    params_array.sort();                    //lexicographically sort parameters by key",
							"    var encoded_params = \"\";               ",
							"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
							"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
							"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
							"    }",
							"     ",
							"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\",timestamp);",
							" ",
							"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
							"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
							"    // console.log(requestData);",
							" ",
							"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
							"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
							"     ",
							"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
							"    var prebase = IKEY+\":\"+ hmacDigest;",
							"    // console.log(\"prebase:\", prebase)",
							"     ",
							"    //encodes a string in base-64",
							"    var baseComplete = btoa(prebase);",
							"",
							"    var authHeader = \"Basic \"+ baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"function urlEncodeParams(value, index, array) {",
							"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
							"}",
							"",
							"// Get Accounts",
							"// Performing this request to pull the list of child accounts",
							"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
							"",
							"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
							"",
							"    pm.sendRequest({",
							"    url: url1,",
							"    method: \"POST\",",
							"    header: {",
							"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"        \"Date\": pm.globals.get(\"timestampHeader\")",
							"    },",
							"    body: {}",
							"    }, function(err, res) {",
							"    if (err) {",
							"        console.log(\"Error:\", err);",
							"        return;",
							"    }",
							"",
							"    // console.log(\"Response Status Code:\", res.code);",
							"    // console.log(\"Raw Response Body:\", res.text());",
							"",
							"    try {",
							"        var responseJson = JSON.parse(res.text());",
							"        if (responseJson.stat === \"OK\") {",
							"            // Initialize an object to store the mapping",
							"            var duoChildAccounts = {};",
							"",
							"            for (var i = 0; i < responseJson.response.length; i++) {",
							"                var accountId = responseJson.response[i].account_id;",
							"                var accountName = responseJson.response[i].name;",
							"                var apiHostname = responseJson.response[i].api_hostname;",
							"",
							"                // Store the account ID, name, and API hostname mapping in duoChildAccounts",
							"                duoChildAccounts[accountId] = {",
							"                    name: accountName,",
							"                    apiHostname: apiHostname",
							"                };",
							"            }",
							"",
							"            // Save the mapping object as a global variable",
							"            pm.globals.set(\"duoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"        } else {",
							"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
							"        }",
							"    } catch (error) {",
							"        console.log(\"Error parsing JSON:\", error);",
							"    }",
							"});",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "parent_account_edition",
			"value": "",
			"type": "string"
		},
		{
			"key": "discount_tier",
			"value": "",
			"type": "string",
			"disabled": true
		},
		{
			"key": "nfr_adjustment",
			"value": "",
			"type": "string",
			"disabled": true
		},
		{
			"key": "child_account_name",
			"value": ""
		},
		{
			"key": "pushPhishGroup",
			"value": ""
		},
		{
			"key": "child_auth_api_matrix",
			"value": ""
		},
		{
			"key": "child_account_account_id",
			"value": ""
		},
		{
			"key": "child_auth_api_host",
			"value": ""
		},
		{
			"key": "child_auth_api_ikey",
			"value": ""
		},
		{
			"key": "child_auth_api_skey",
			"value": ""
		},
		{
			"key": "duoChildAccounts",
			"value": ""
		}
	]
}