{
	"info": {
		"_postman_id": "c8d17b77-2c05-47db-8f54-6c5c00f2a498",
		"name": "7. Duo Administrative Tasks",
		"description": "In this collection, we've included a number of requests to address some common MSP use cases.\n\n_**Note:**_ Be sure to refer to the **Duo Accounts API** and **Duo Admin API \\[Parent\\]** collections, and ensure the Accounts API and Admin request credentials have been populated in the global variables before continuing. If you do not poulate the variables as defined in those two collections, some requst in this collection will not work properly.\n\n#### ðŸš€ Getting familiar with this collection\n\n- **Bypass Users:** The requests in this folder allow pulling a list of users in Bypass status across all sub-accounts and _if desired_ setting those users to Active status\n    - _Get Users in Bypass status:_ Pulls the full list of users in Bypass status accross all child accounts and stores the users in the `bypassUserList` global variable.\n    - _Set users in Bypass status to Active status:_ Iterates over that list of users in the `bypassUserList`, and sends individual calls to each account to set these users to 'Active' status.\n    - **Note:** _The sequence of requests is comprehensive. If you have users you wish to maintain in 'Bypass' status, they should be removed from the_ `bypassUserList` _global variable before running the 'Set Users in Bypass status to Active' request._\n- **Cost Report:** The \"Cost Report\" comprises multiple request designed to provide a detailed breakdown of your current Duo usage, including the total number of users, the associated edition (Essentials, Advantage, Premier), and the corresponding costs. It provides both a console-friendly table and a CSV report of each client's Duo usage.\n    - **Important Note**: _The Duo Admin API doesn't offer a method to retrieve the edition of the parent account natively, so to work aroud this, we have added a collection variable_ `parent_account_edition_`_that must be manually set to the edition of the parent account. It must be one of..._\n        - Duo Essentials\n        - Duo Advantage\n        - Duo Premier\n- **Policy Management:** The request in this folder updates the global policy for each Duo child account using the list of account IDs in duoChildAccounts.\n    - Update Policy Section Data: Navigate to the Body tab of the 'Update Global Policy' request and modify the policy section data to align with your desired security policies. See [Policy Section Data](https://duo.com/docs/adminapi#policy-section-data)\n    - Update Global Policy : Execute the 'Update Global Policy' request. This process iterates over each ID in your duoChildAccounts, applying the newly configured global policy settings to all your Duo child accounts.\n- Universal Prompt: The requests in this folder automates the updating of in scope applications to the Universal Prompt across the full list of child accounts. It involves two key steps:\n    \n    1. **Retrieve V4 Integrations**: This step iterates over the list child account IDs to identify and collect applications eligible for the Universal Prompt update. These applications are stored in a variable (universal_prompt_ikeys), mapped by account ID, account name, and integration keys.\n        \n    2. **Enable Universal Prompt**: The next step takes the identified integration keys and activates the Universal Prompt for these applications on the target accounts.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "27165404",
		"_collection_link": "https://duomsp.postman.co/workspace/Duo-MSP-API-Playground~c7115430-1cbf-4f66-9ded-2a737488a755/collection/27165404-c8d17b77-2c05-47db-8f54-6c5c00f2a498?action=share&source=collection_link&creator=27165404"
	},
	"item": [
		{
			"name": "Bypass Users",
			"item": [
				{
					"name": "Users in 'Bypass' status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Initialize DuoChildAccounts as an empty object\r",
									"var DuoChildAccounts = {};\r",
									"\r",
									"// HMAC 1 - Get HMAC authentication header\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY\r",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname\r",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type\r",
									"\r",
									"    // Check if the API hostname is defined. If not, throw an error.\r",
									"    if (!API_HOSTNAME) {\r",
									"        throw new Error(\"API_HOSTNAME is not defined\");\r",
									"    }\r",
									"     \r",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    // Get the index of the start of the query parameters in the URL \r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"\r",
									"    // Calculate the length of the hostname\r",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;\r",
									"\r",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call\r",
									"     \r",
									"    // Clean up api_call by removing any unwanted characters\r",
									"    api_call = api_call.replace(\"}}\", \"\");\r",
									"    // console.log('api_call:', api_call);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"    //Create unsorted array of parameters from either URL or Body\r",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL\r",
									"    //(technically it looks like POST can be in the URL as well)\r",
									"\r",
									"    // Depending on the HTTP method and the existence of a request body,\r",
									"    // extract the query parameters from the URL or the body into params_array\r",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {\r",
									"        for (var parameter1 in requestBody) {\r",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart+1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"     \r",
									"    params_array.sort();                    //lexicographically sort parameters by key\r",
									"    var encoded_params = \"\";               \r",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array\r",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &\r",
									"    }\r",
									"     \r",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\",timestamp);\r",
									" \r",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines\r",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;\r",
									"    // console.log(requestData);\r",
									" \r",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key\r",
									"    var CryptoJS = require('crypto-js');\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"     \r",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.\r",
									"    var prebase = IKEY+\":\"+ hmacDigest;\r",
									"    // console.log(\"prebase:\", prebase)\r",
									"     \r",
									"    //encodes a string in base-64\r",
									"    var btoa = require('btoa');\r",
									"    var baseComplete = btoa(prebase);\r",
									"\r",
									"    var authHeader = \"Basic \"+ baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"// HMAC 2 - Get HMAC authentication header\r",
									"function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
									"    var AUTH_TYPE = 'HMAC-SHA1';\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8;\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        for (var parameter1 in requestBody) {\r",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    var CryptoJS = require('crypto-js');\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var baseComplete = btoa(prebase);\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"// Request 1 - Get Accounts\r",
									"function getAccounts() {\r",
									"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;\r",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));\r",
									"\r",
									"    pm.sendRequest({\r",
									"        url: url1,\r",
									"        method: \"POST\",\r",
									"        header: {\r",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
									"            \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"        },\r",
									"        body: {}\r",
									"    }, function(err, res) {\r",
									"        if (err) {\r",
									"            console.log(\"Error:\", err);\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        try {\r",
									"            var responseJson = JSON.parse(res.text());\r",
									"            if (responseJson.stat === \"OK\") {\r",
									"                var DuoChildAccounts = {};\r",
									"                responseJson.response.forEach(account => {\r",
									"                    DuoChildAccounts[account.account_id] = {\r",
									"                        name: account.name,\r",
									"                        apiHostname: account.api_hostname\r",
									"                    };\r",
									"                });\r",
									"\r",
									"                // Save the mapping object as a global variable\r",
									"                pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));\r",
									"\r",
									"                // Proceed to the next request\r",
									"                getBypassUsers(DuoChildAccounts);\r",
									"            } else {\r",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);\r",
									"            }\r",
									"        } catch (error) {\r",
									"            console.log(\"Error parsing JSON:\", error);\r",
									"        }\r",
									"    });\r",
									"}\r",
									"\r",
									"// Clear Global Variables\r",
									"function clearGlobalVariables() {\r",
									"    pm.globals.unset(\"timestampHeader\");\r",
									"    pm.globals.unset(\"hmacAuthHeader\");\r",
									"    pm.globals.unset(\"hmacAuthHeader2\");\r",
									"    pm.globals.unset(\"accountId\");\r",
									"    pm.globals.unset(\"next_offset\");\r",
									"}\r",
									"\r",
									"// Request 2 - Get Bypass Users\r",
									"function getBypassUsers(DuoChildAccounts) {\r",
									"    var bypassUserList = {};\r",
									"    var keys = Object.keys(DuoChildAccounts);\r",
									"    processAccount(keys, 0);\r",
									"\r",
									"    function processAccount(keys, index, offset = 0) {\r",
									"        if (index >= keys.length) {\r",
									"            // All accounts have been processed\r",
									"            console.log(\"Bypass Users List\");\r",
									"            let bypassUserFound = false;\r",
									"            for (let accountId in bypassUserList) {\r",
									"                let accountData = bypassUserList[accountId];\r",
									"                if (accountData.users.length > 0) {\r",
									"                    bypassUserFound = true;\r",
									"                    // console.log(\"Account Name\\t\\tBypass Users\");\r",
									"                   console.log(`${accountData.account_name}: ${accountData.users.map(user => user.username).join(\", \")}`);\r",
									"                }\r",
									"            }\r",
									"\r",
									"            if (!bypassUserFound) {\r",
									"                console.log(\"There are no users in Bypass status across your client accounts.\");\r",
									"                // No need to set bypassUserList as a global variable if no users found\r",
									"            } else {\r",
									"                pm.globals.set(\"bypassUserList\", JSON.stringify(bypassUserList));\r",
									"            }\r",
									"\r",
									"            clearGlobalVariables(); // Clear global variables after processing\r",
									"            return;\r",
									"        }\r",
									"\r",
									"        let accountId = keys[index];\r",
									"        var accountDetails = DuoChildAccounts[accountId];\r",
									"        var urlWithAccountId = `https://${accountDetails.apiHostname}/admin/v1/users?account_id=${accountId}&offset=${offset}`;\r",
									"\r",
									"        pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", urlWithAccountId, {}, accountDetails.apiHostname));\r",
									"\r",
									"        pm.sendRequest({\r",
									"            url: urlWithAccountId,\r",
									"            method: \"GET\",\r",
									"            header: {\r",
									"                \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),\r",
									"                \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"            },\r",
									"            body: {}\r",
									"        }, function(err, res) {\r",
									"            if (err) {\r",
									"                console.error('Request failed for account:', accountDetails.name, '; Error:', err);\r",
									"                processAccount(keys, index + 1);\r",
									"                return;\r",
									"            }\r",
									"\r",
									"            if (res.code === 200) {\r",
									"                var resJson = res.json();\r",
									"                var bypassUsers = resJson.response.filter(user => user.status === 'bypass')\r",
									"                    .map(user => ({ username: user.username, user_id: user.user_id }));\r",
									"\r",
									"                if (bypassUsers.length > 0) {\r",
									"                    if (!bypassUserList[accountId]) {\r",
									"                        bypassUserList[accountId] = {\r",
									"                            account_name: accountDetails.name,\r",
									"                            users: []\r",
									"                        };\r",
									"                    }\r",
									"                    bypassUserList[accountId].users.push(...bypassUsers);\r",
									"                }\r",
									"\r",
									"                // Check for next offset\r",
									"                if (resJson.metadata && resJson.metadata.next_offset) {\r",
									"                    processAccount(keys, index, resJson.metadata.next_offset);\r",
									"                } else {\r",
									"                    processAccount(keys, index + 1);\r",
									"                }\r",
									"            } else {\r",
									"                console.error('Request failed for account:', accountDetails.name, '; Response:', res);\r",
									"                processAccount(keys, index + 1);\r",
									"            }\r",
									"        });\r",
									"    }\r",
									"}\r",
									"\r",
									"// Start the process\r",
									"getAccounts();\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// var bypassUserList = JSON.parse(pm.globals.get(\"bypassUserList\"));",
									"",
									"// // Check if bypassUserList is empty",
									"// if (Object.keys(bypassUserList).length === 0) {",
									"//     console.log(\"There are no users in Bypass status.\");",
									"// } else {",
									"//     // List accounts with bypass users",
									"//     console.log(\"The following users are in Bypass status:\");",
									"//     for (var accountKey in bypassUserList) {",
									"//         var accountData = bypassUserList[accountKey];",
									"//         var userList = accountData.users.map(user => user.username).join(\", \");",
									"//         console.log(accountData.account_name.split(':')[0].trim() + \": \" + userList);",
									"//     }",
									"// }",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				},
				{
					"name": "Set 'Bypass' users to 'Active' status",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variables declaration section\r",
									"var bypassUserListString = pm.globals.get(\"bypassUserList\");\r",
									"var bypassUserList;\r",
									"var DuoChildAccounts;\r",
									"\r",
									"try {\r",
									"    bypassUserList = JSON.parse(bypassUserListString);\r",
									"    DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
									"} catch (e) {\r",
									"    console.error(\"Error parsing JSON: \", e);\r",
									"    return; // Stop execution if parsing fails\r",
									"}\r",
									"\r",
									"// Check if bypassUserList is empty\r",
									"if (!bypassUserList || Object.keys(bypassUserList).length === 0) {\r",
									"    console.log(\"bypassUserList is empty or not defined.\");\r",
									"    clearGlobalVariables(); // Clear global variables\r",
									"    return; // Exit if there's nothing to process\r",
									"}\r",
									"\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Accounts API SKEY\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") == -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8;\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    // Ensure requestBody is an object\r",
									"    if (!requestBody || Object.keys(requestBody).length === 0) {\r",
									"        requestBody = {};\r",
									"    }\r",
									"\r",
									"    for (var parameter1 in requestBody) {\r",
									"        params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
									"        params_array.push(params_unsorted);\r",
									"    }\r",
									"\r",
									"    if (params_array.length === 0) {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    var CryptoJS = require('crypto-js');\r",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
									"\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var btoa = require('btoa');\r",
									"    var baseComplete = btoa(prebase);\r",
									"\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"// Loop over each Account in the bypassUserList\r",
									"for (let accountKey in bypassUserList) {\r",
									"    let accountData = bypassUserList[accountKey];\r",
									"    let accountId;\r",
									"    let accountDetails;\r",
									"\r",
									"    // Check if accountKey is a valid JSON string\r",
									"    try {\r",
									"        let parsedKey = JSON.parse(accountKey);\r",
									"        accountId = parsedKey.account_id;\r",
									"    } catch (e) {\r",
									"        // If it's not a valid JSON, use accountKey directly\r",
									"        accountId = accountKey;\r",
									"    }\r",
									"\r",
									"    accountDetails = DuoChildAccounts[accountId];\r",
									"    if (!accountDetails) {\r",
									"        console.error(\"Account details not found for account ID: \", accountId);\r",
									"        continue;\r",
									"    }\r",
									"\r",
									"    let accountName = accountDetails.name;\r",
									"    let apiHostname = accountDetails.apiHostname; // Get the apiHostname for the current account\r",
									"\r",
									"    let processedUsers = []; // Array to hold processed usernames\r",
									"    let userPromises = []; // Array to hold promises\r",
									"\r",
									"    if (Array.isArray(accountData.users)) {\r",
									"        accountData.users.forEach(function(user) {\r",
									"            // Construct the URL for the API call, using the current accountId, user_id, and specific apiHostname\r",
									"            var postUrlWithAccountIdAndUserId = `https://${apiHostname}/admin/v1/users/${user.user_id}?account_id=${accountId}&status=active`;\r",
									"\r",
									"            // Call the getAuthHeader function to generate the HMAC auth header for this API request\r",
									"            var postHmacAuthHeader = getAuthHeader(\"POST\", postUrlWithAccountIdAndUserId, {}, apiHostname);\r",
									"\r",
									"            // Create a new promise for each request\r",
									"            let userPromise = new Promise((resolve, reject) => {\r",
									"                pm.sendRequest({\r",
									"                    url: postUrlWithAccountIdAndUserId,\r",
									"                    method: \"POST\",\r",
									"                    header: {\r",
									"                        \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"                        \"Authorization\": postHmacAuthHeader,\r",
									"                        \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"                    },\r",
									"                    body: {}\r",
									"                }, function(postErr, postRes) {\r",
									"                    if (postRes.code === 200 && postRes.json().stat === \"OK\") {\r",
									"                        processedUsers.push(user.username); // Add username to the array\r",
									"                        resolve();\r",
									"                    } else {\r",
									"                        console.error(\"There was an error when processing user with ID: \" + user.user_id);\r",
									"                        console.error(postErr);\r",
									"                        reject();\r",
									"                    }\r",
									"                });\r",
									"            });\r",
									"\r",
									"            userPromises.push(userPromise);\r",
									"        });\r",
									"\r",
									"        // Wait for all promises to resolve\r",
									"        Promise.all(userPromises).then(() => {\r",
									"            if (processedUsers.length > 0) {\r",
									"                console.log(\"The following users have been set to Active status on \" + accountName + \": \" + processedUsers.join(\", \"));\r",
									"            }\r",
									"        }).catch((error) => {\r",
									"            console.error(\"Error in processing users for account:\", accountName, \"; Error:\", error);\r",
									"        });\r",
									"    } else {\r",
									"        console.error(\"Users is not an array for account:\", accountName);\r",
									"    }\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"// Get the last account data and user\r",
									"var lastAccountKeyString = Object.keys(bypassUserList).pop();\r",
									"\r",
									"if (lastAccountKeyString) {\r",
									"    var lastAccountData = bypassUserList[lastAccountKeyString];\r",
									"    var lastAccountDetails = DuoChildAccounts[lastAccountKeyString]; // Directly use lastAccountKeyString\r",
									"\r",
									"    if (lastAccountData && Array.isArray(lastAccountData.users) && lastAccountData.users.length > 0) {\r",
									"        var lastUser = lastAccountData.users[lastAccountData.users.length - 1];\r",
									"        var lastUserApiHostname = lastAccountDetails.apiHostname; // Use lastAccountDetails\r",
									"\r",
									"        // Set the global variables\r",
									"        pm.globals.set(\"user_id\", lastUser.user_id);\r",
									"        pm.globals.set(\"account_id\", lastAccountKeyString); // Use lastAccountKeyString directly\r",
									"\r",
									"        // Construct the URL for the API call\r",
									"        var mainUrlWithAccountIdAndUserId = `https://${lastUserApiHostname}/admin/v1/users/${lastUser.user_id}?account_id=${lastAccountKeyString}&status=active`;\r",
									"\r",
									"        // Call the getAuthHeader function\r",
									"        var mainHmacAuthHeader = getAuthHeader(\"POST\", mainUrlWithAccountIdAndUserId, {}, lastUserApiHostname);\r",
									"        pm.globals.set(\"hmacAuthHeader\", mainHmacAuthHeader);\r",
									"    } else {\r",
									"        console.error(\"No users found in the last account data or lastAccountData.users is not an array.\");\r",
									"    }\r",
									"} else {\r",
									"    console.error(\"lastAccountKeyString is undefined or not found in bypassUserList.\");\r",
									"}\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"function clearGlobalVariables() {",
									"    var variablesToClear = [\"user_id\", \"account_id\", \"timestampHeader\", \"hmacAuthHeader\", \"hmacAuthHeader2\", \"bypassUserList\", \"duoChildAccounts\"];",
									"    variablesToClear.forEach(function(variableName) {",
									"        pm.globals.unset(variableName);",
									"    });",
									"    // console.log(\"Global variables cleared.\");",
									"}",
									"",
									"// Call the function to clear the variables",
									"clearGlobalVariables();",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				}
			],
			"description": "The requests in this folder allow pulling a list of users in Bypass status across all sub-accounts and _if desired_ setting those users to Active status\n\n- _Get Users in Bypass status:_ Pulls the full list of users in Bypass status accross all child accounts and stores the users in the `bypassUserList` global variable.\n    \n- _Set users in Bypass status to Active status:_ Iterates over that list of users in the `bypassUserList`, and sends individual calls to each account to set these users to 'Active' status.\n    \n- **Note:** _The sequence of requests is comprehensive. If you have users you wish to maintain in 'Bypass' status, they should be removed from the_ `bypassUserList` _global variable before running the 'Set Users in Bypass status to Active' request._",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Cost Report",
			"item": [
				{
					"name": "Cost Report",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"try {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"",
									"    var totalUsersByEdition = {};",
									"",
									"    for (let accountId in DuoChildAccounts) {",
									"        if (DuoChildAccounts.hasOwnProperty(accountId)) {",
									"            let accountDetails = DuoChildAccounts[accountId];",
									"            let edition = accountDetails.edition;",
									"            let userCount = parseInt(accountDetails.userCount, 10);",
									"",
									"            if (totalUsersByEdition.hasOwnProperty(edition)) {",
									"                totalUsersByEdition[edition] += userCount;",
									"            } else {",
									"                totalUsersByEdition[edition] = userCount;",
									"            }",
									"        }",
									"    }",
									"",
									"    var parentAccountEdition = pm.collectionVariables.get(\"parent_account_edition\");",
									"    var parentAccountUserCount = parseInt(pm.globals.get(\"parent_account_user_count\"), 10);",
									"",
									"    var parentEditionKey = \"\";",
									"    switch (parentAccountEdition) {",
									"        case \"Duo Essentials\":",
									"            parentEditionKey = \"ENTERPRISE\";",
									"            break;",
									"        case \"Duo Advantage\":",
									"            parentEditionKey = \"PLATFORM\";",
									"            break;",
									"        case \"Duo Premier\":",
									"            parentEditionKey = \"BEYOND\";",
									"            break;",
									"        default:",
									"            throw new Error(`Parent account edition is currently set to (${parentAccountEdition}). Please update the parent_account_edition collection variable to one of: Duo Essentials, Duo Advantage, or Duo Premier`);",
									"    }",
									"",
									"    if (totalUsersByEdition.hasOwnProperty(parentEditionKey)) {",
									"        totalUsersByEdition[parentEditionKey] += parentAccountUserCount;",
									"    } else {",
									"        totalUsersByEdition[parentEditionKey] = parentAccountUserCount;",
									"    }",
									"",
									"    var basePrices = {",
									"        \"ENTERPRISE\": 3,",
									"        \"PLATFORM\": 6,",
									"        \"BEYOND\": 9",
									"    };",
									"",
									"    console.log(pm.globals.get(\"parent_account_name\") + \" Account Summary \" + new Date().toLocaleString('default', { month: 'short', year: '2-digit' }));",
									"",
									"    var maxEditionLength = 0;",
									"    var maxUserCountLength = 0;",
									"    var maxDiscountTierLength = 0;",
									"    var maxUnitPriceLength = 0;",
									"    var totalUserCount = 0;",
									"",
									"    for (let edition in totalUsersByEdition) {",
									"        if (edition.length > maxEditionLength) {",
									"            maxEditionLength = edition.length;",
									"        }",
									"        let userCount = totalUsersByEdition[edition].toString();",
									"        if (userCount.length > maxUserCountLength) {",
									"            maxUserCountLength = userCount.length;",
									"        }",
									"        let discountTier = getDiscountTier(totalUsersByEdition[edition]);",
									"        if (discountTier.length > maxDiscountTierLength) {",
									"            maxDiscountTierLength = discountTier.length;",
									"        }",
									"        let basePrice = basePrices[edition] || 0;",
									"        let unitPrice = getUnitPrice(basePrice, discountTier);",
									"        let unitPriceString = unitPrice.toFixed(2);",
									"        if (unitPriceString.length > maxUnitPriceLength) {",
									"            maxUnitPriceLength = unitPriceString.length;",
									"        }",
									"        totalUserCount += totalUsersByEdition[edition];",
									"    }",
									"",
									"    var editionNames = {",
									"        \"ENTERPRISE\": \"Duo Essentials\",",
									"        \"PLATFORM\": \"Duo Advantage\",",
									"        \"BEYOND\": \"Duo Premier\"",
									"    };",
									"",
									"    console.log(\"Edition\".padEnd(maxEditionLength + 5) + \"User Count\".padEnd(maxUserCountLength + 10) + \"Base Price\".padEnd(13) + \"Discount Tier\".padEnd(maxDiscountTierLength + 12) + \"Unit Price\");",
									"",
									"    var sortedEditions = Object.keys(totalUsersByEdition).sort((a, b) => {",
									"        if (a === \"ENTERPRISE\") return -1;",
									"        if (a === \"PLATFORM\" && b !== \"ENTERPRISE\") return -1;",
									"        return 1;",
									"    });",
									"",
									"    var totalCost = 0;",
									"",
									"    for (let edition of sortedEditions) {",
									"        let userCount = totalUsersByEdition[edition];",
									"        let basePrice = basePrices[edition] || 0;",
									"        let discountTier = getDiscountTier(userCount);",
									"        let unitPrice = getUnitPrice(basePrice, discountTier);",
									"        let editionName = editionNames[edition];",
									"        console.log(editionName.padEnd(maxEditionLength + 9) + userCount.toString().padEnd(maxUserCountLength + 11) + \"$\" + basePrice.toString().padEnd(12) + discountTier.padEnd(maxDiscountTierLength + 11) + \"$\" + unitPrice.toFixed(2));",
									"",
									"        totalCost += userCount * unitPrice;",
									"    }",
									"    console.log(\"Note: Parent Account users have been included in these calculations minus the NFR adjustment\")",
									"    console.log(`Total Users: ${totalUserCount}\\n Total Cost: $${totalCost.toFixed(2)}`);",
									"",
									"    function getDiscountTier(userCount) {",
									"        var discountTier = pm.collectionVariables.get(\"discount_tier\");",
									"        if (discountTier) {",
									"            return discountTier + \"%\";",
									"        }",
									"",
									"        if (userCount >= 1 && userCount <= 999) {",
									"            return \"10%\";",
									"        } else if (userCount >= 1000 && userCount <= 4999) {",
									"            return \"20%\";",
									"        } else if (userCount >= 5000 && userCount <= 24999) {",
									"            return \"30%\";",
									"        } else if (userCount >= 25000 && userCount <= 124999) {",
									"            return \"40%\";",
									"        } else if (userCount >= 125000) {",
									"            return \"50%\";",
									"        } else {",
									"            return \"0%\";",
									"        }",
									"    }",
									"",
									"    function getUnitPrice(basePrice, discountTier) {",
									"        let discountPercentage = parseFloat(discountTier) / 100;",
									"        return basePrice - (basePrice * discountPercentage);",
									"    }",
									"",
									"    var csvContent = \"Please find a CSV breakdown of each customer's account summary below. You can copy the CSV content into the spreadsheet program of your choice (such as Microsoft Excel or Google Sheets) for easier viewing and analysis.\\n\\nAccount Name, Edition, Base Price, User Count, Cost\\n\";",
									"",
									"    for (let accountId in DuoChildAccounts) {",
									"        if (DuoChildAccounts.hasOwnProperty(accountId)) {",
									"            let accountDetails = DuoChildAccounts[accountId];",
									"            let accountName = accountDetails.name;",
									"            let edition = editionNames[accountDetails.edition];",
									"            let userCount = parseInt(accountDetails.userCount, 10);",
									"            let basePrice = basePrices[accountDetails.edition] || 0;",
									"            let cost = basePrice * userCount;",
									"            let csvLine = `${accountName},${edition},$${basePrice},${userCount},$${cost}\\n`;",
									"            csvContent += csvLine;",
									"        }",
									"    }",
									"",
									"    ",
									"    console.log(csvContent);",
									"",
									"    pm.globals.unset(\"duoChildAccounts\");",
									"",
									"} catch (error) {",
									"    console.log(\"Error:\", error);",
									"}",
									"",
									"// Deleting the variables",
									"var variablesToDelete = [",
									"    \"timestampHeader\",",
									"    \"hmacAuthHeader\",",
									"    \"hmacAuthHeader2\",",
									"    \"hmacAuthHeader3\",",
									"    \"parent_account_name\",",
									"    \"parent_account_user_count\",",
									"    \"next_offset\"",
									"];",
									"",
									"variablesToDelete.forEach(function(variableName) {",
									"    pm.globals.unset(variableName);",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Initialize DuoChildAccounts as an empty object",
									"var DuoChildAccounts = {};",
									"",
									"// HMAC 1 - Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"    // Check if the API hostname is defined. If not, throw an error.",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"     ",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Get the index of the start of the query parameters in the URL ",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"     ",
									"    // Clean up api_call by removing any unwanted characters",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"    // console.log('api_call:', api_call);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    //Create unsorted array of parameters from either URL or Body",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL",
									"    //(technically it looks like POST can be in the URL as well)",
									"",
									"    // Depending on the HTTP method and the existence of a request body,",
									"    // extract the query parameters from the URL or the body into params_array",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"     ",
									"    params_array.sort();                    //lexicographically sort parameters by key",
									"    var encoded_params = \"\";               ",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"    }",
									"     ",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									"    // console.log(requestData);",
									" ",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    // console.log(\"prebase:\", prebase)",
									"     ",
									"    //encodes a string in base-64",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"// HMAC 2 - Get HMAC authentication header",
									"function getAuthHeader2(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.globals.get(\"parent_admin_api_ikey\"); //Auth or Admin API IKEY",
									"    var SKEY = pm.globals.get(\"parent_admin_api_skey\"); //Auth or Admin API SKEY",
									"    var API_HOSTNAME = pm.globals.get(\"parent_admin_api_host\"); //Auth or Admin API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"    // Check if the API hostname is defined. If not, throw an error.",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"     ",
									"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Get the index of the start of the query parameters in the URL ",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"     ",
									"    // Clean up api_call by removing any unwanted characters",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"    // console.log('api_call:', api_call);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    //Create unsorted array of parameters from either URL or Body",
									"    //Assuming POST parameters are in the Body, GET paramters are in URL",
									"    //(technically it looks like POST can be in the URL as well)",
									"",
									"    // Depending on the HTTP method and the existence of a request body,",
									"    // extract the query parameters from the URL or the body into params_array",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"     ",
									"    params_array.sort();                    //lexicographically sort parameters by key",
									"    var encoded_params = \"\";               ",
									"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"    }",
									"     ",
									"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									"    // console.log(requestData);",
									" ",
									"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    // console.log(\"prebase:\", prebase)",
									"     ",
									"    //encodes a string in base-64",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"// HMAC 3 - Get HMAC authentication header",
									"function getAuthHeader3(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
									"    var AUTH_TYPE = 'HMAC-SHA1';",
									"",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"",
									"    if (Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"",
									"    params_array.sort();",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value, index, array) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Request 1 - Get Accounts",
									"function getAccounts() {",
									"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url1,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            if (responseJson.stat === \"OK\") {",
									"                // Populate DuoChildAccounts",
									"                responseJson.response.forEach(account => {",
									"                    DuoChildAccounts[account.account_id] = {",
									"                        name: account.name,",
									"                        apiHostname: account.api_hostname",
									"                    };",
									"                });",
									"",
									"                // Save the mapping object as a global variable",
									"                pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"",
									"                // Proceed to the next request",
									"                getSettings();",
									"            } else {",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 2 - Get Settings",
									"function getSettings() {",
									"    var url = `https://${pm.globals.get(\"parent_admin_api_host\")}/admin/v1/settings`;",
									"    pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            if (responseJson.stat === \"OK\") {",
									"                var name = responseJson.response.name;",
									"                pm.globals.set(\"parent_account_name\", name);",
									"",
									"                // Proceed to the next request",
									"                getAccountSummary();",
									"            } else {",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 3 - Get Account Summary",
									"function getAccountSummary() {",
									"    var url = `https://${pm.globals.get(\"parent_admin_api_host\")}/admin/v1/info/summary`;",
									"    pm.globals.set(\"hmacAuthHeader2\", getAuthHeader2(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader2\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error:\", err);",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseJson = JSON.parse(res.text());",
									"            var userCount = responseJson.response.user_count;",
									"            var nfr_adjustment = pm.collectionVariables.get(\"nfr_adjustment\");",
									"            var adjustmentValue = nfr_adjustment ? parseInt(nfr_adjustment, 10) : 50;",
									"            var parentAccountUserCount = (userCount >= adjustmentValue) ? userCount - adjustmentValue : 0;",
									"            pm.globals.set(\"parent_account_user_count\", parentAccountUserCount.toString());",
									"",
									"            // Proceed to the next request",
									"            processAccounts();",
									"        } catch (error) {",
									"            console.log(\"Error parsing JSON:\", error);",
									"        }",
									"    });",
									"}",
									"",
									"// Request 4 - Get Edition for each account",
									"function processAccounts() {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"    var keys = Object.keys(DuoChildAccounts);",
									"    processAccount(keys, 0);",
									"    }",
									"",
									"    function processAccount(keys, index) {",
									"    if (index >= keys.length) {",
									"        // All accounts have been processed",
									"        pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"",
									"        // Now call getUserCounts",
									"        getUserCounts();",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    var accountDetails = DuoChildAccounts[accountId];",
									"    var apiHostname = accountDetails.apiHostname;",
									"",
									"    var urlWithAccountId = `https://${apiHostname}/admin/v1/billing/edition?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
									"    pm.globals.set(\"hmacAuthHeader3\", getAuthHeader3(\"GET\", urlWithAccountId, {}, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader3\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error('Request failed for account:', accountDetails.name, '; Error:', err);",
									"            processAccount(keys, index + 1); // Move to the next account in case of an error",
									"            return;",
									"        }",
									"",
									"        if (res.code === 200) {",
									"            var resJson = res.json();",
									"            var edition = resJson.response.edition;",
									"            DuoChildAccounts[accountId].edition = edition;",
									"",
									"            if (resJson.metadata && resJson.metadata.next_offset) {",
									"                pm.globals.set('next_offset', resJson.metadata.next_offset);",
									"                processAccount(keys, index); // Continue with the same account",
									"            } else {",
									"                pm.globals.set('next_offset', 0);",
									"                processAccount(keys, index + 1); // Move to the next account",
									"            }",
									"        } else {",
									"            console.error('Request failed for account:', accountDetails.name, '; Response:', res);",
									"            processAccount(keys, index + 1); // Move to the next account in case of an error",
									"        }",
									"    });",
									"}",
									"",
									"//Request 5 - Get User Count for each account",
									"function getUserCounts() {",
									"    var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));",
									"    var keys = Object.keys(DuoChildAccounts);",
									"    processUserCount(keys, 0);",
									"}",
									"",
									"function processUserCount(keys, index) {",
									"    if (index >= keys.length) {",
									"        // All accounts have been processed",
									"        pm.globals.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    var accountDetails = DuoChildAccounts[accountId];",
									"    var apiHostname = accountDetails.apiHostname;",
									"",
									"    var urlWithAccountId = `https://${apiHostname}/admin/v1/info/summary?account_id=${accountId}`;",
									"    pm.globals.set(\"hmacAuthHeader3\", getAuthHeader3(\"GET\", urlWithAccountId, {}, apiHostname));",
									"",
									"    pm.sendRequest({",
									"        url: urlWithAccountId,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader3\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.log(\"Error fetching user count for account ID:\", accountId, \"; Error:\", err);",
									"            processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"            return;",
									"        }",
									"",
									"        try {",
									"            var responseData = JSON.parse(res.text());",
									"            if (responseData && responseData.stat === \"OK\") {",
									"                DuoChildAccounts[accountId].userCount = responseData.response.user_count;",
									"                processUserCount(keys, index + 1); // Move to the next account",
									"            } else {",
									"                console.log(\"Error: Response status is not OK for account ID:\", accountId);",
									"                processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"            }",
									"        } catch (error) {",
									"            console.log(\"Error parsing response body as JSON:\", error);",
									"            processUserCount(keys, index + 1); // Move to the next account in case of an error",
									"        }",
									"    });",
									"}",
									"",
									"// Start the sequence",
									"getAccounts();",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						},
						"description": "Returns a list of child accounts."
					},
					"response": []
				}
			],
			"description": "This comprehensive report provides a detailed breakdown of your current Duo usage, including the total number of users, their associated edition (Essentials, Advantage, Premier), and corresponding costs. It offers both a console-friendly table and a CSV report for each client's Duo usage.\n\n- [Get Accounts](https://duo.com/docs/accountsapi#retrieve-accounts)**:** This request retrieves a list of all child accounts and stores them in the `duoChildAccounts` collection variable, which includes Account Name, Account ID, and API Hostname.\n- [Get Settings](https://duo.com/docs/adminapi#retrieve-settings)**:** Specifically used to extract the parent account's name, this request stores it temporarily as the variable parent_account_name for use in the Cost Report.\n- [Get Account Summary](https://duo.com/docs/adminapi#retrieve-summary)**:** This request fetches the user accounts and editions of the parent account.\n- Get Edition**:** This request iterates over each child account in `duoChildAccounts` and retrieves the edition for each account.\n    \n- Get User Count: This request iterates over each child account in `duoChildAccounts` and pulls a user count\n    \n\nWith all data stored, we aggregate it to construct the Cost Report.\n\n**Important Note:** The Duo Admin API does not provide a native method to retrieve the edition of the parent account. To address this, we've introduced the collection variable parent_account_edition, which must be manually set to the parent account's edition. Please ensure correct spelling and selection from the following options:\n\n- Duo Essentials\n- Duo Advantage\n- Duo Premier\n    \n\nFailure to provide the correct edition name may result in unsuccessful execution of the function."
		},
		{
			"name": "Policy Management",
			"item": [
				{
					"name": "Update Global Policy",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variable Declaration",
									"var DuoChildAccounts = JSON.parse(pm.collectionVariables.get(\"duoChildAccounts\"));",
									"",
									"// Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"    var params_array = params_unsorted.split(\"&\");",
									"    params_array.sort();",
									"    var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var CryptoJS = require('crypto-js');",
									"",
									"    var jsonDataString = JSON.stringify(requestBody);",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"    // console.log(\"Request Data for HMAC:\", requestData);",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"var keys = Object.keys(DuoChildAccounts);",
									"processAccount(keys, 0);",
									"",
									"function processAccount(keys, index) {",
									"    if (index >= keys.length) {",
									"        console.log(\"All accounts have been processed\");",
									"",
									"        // Unset global variables after processing all accounts",
									"        pm.globals.unset(\"newChildAccount\");",
									"        pm.globals.unset(\"timestampHeader\");",
									"        pm.globals.unset(\"hmacAuthHeader\");",
									"",
									"        return;",
									"    }",
									"",
									"    let accountId = keys[index];",
									"    if (accountId && accountId.trim() !== \"\") {",
									"        var accountDetails = DuoChildAccounts[accountId];",
									"",
									"        if (!accountDetails) {",
									"            console.error('Account details not found for account ID:', accountId);",
									"            processAccount(keys, index + 1);",
									"            return;",
									"        }",
									"",
									"        var accountName = accountDetails.name;",
									"        var apiHostname = accountDetails.apiHostname;",
									"        var globalPolicyKey = accountDetails.globalPolicyKey;",
									"",
									"        if (!globalPolicyKey) {",
									"            console.error('Global policy key not found for account:', accountName);",
									"            processAccount(keys, index + 1);",
									"            return;",
									"        }",
									"",
									"        var urlWithAccountId = `https://${apiHostname}/admin/v2/policies/${globalPolicyKey}?account_id=${accountId}`;",
									"",
									"        // Fetching requestBody from the Pre-request Script or Tests script section of Postman",
									"        var requestBody = pm.request.body ? JSON.parse(pm.request.body.raw) : {};",
									"",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"PUT\", urlWithAccountId, requestBody, apiHostname));",
									"",
									"        pm.sendRequest({",
									"            url: urlWithAccountId,",
									"            method: \"PUT\",",
									"            header: {",
									"                \"Content-Type\": \"application/json\",",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"                \"Date\": pm.globals.get(\"timestampHeader\")",
									"            },",
									"            body: {",
									"                mode: 'raw',",
									"                raw: JSON.stringify(requestBody)",
									"            }",
									"        }, function (err, res) {",
									"            if (res.code === 200) {",
									"                console.log('Global policy updated for account:', accountName);",
									"            } else {",
									"                console.error('Request failed for account:', accountName, '; Error:', err, '; Response:', res);",
									"            }",
									"",
									"            processAccount(keys, index + 1);",
									"        });",
									"    } else {",
									"        console.error('Invalid account ID:', accountId);",
									"        processAccount(keys, index + 1);",
									"    }",
									"}",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n            \"is_global_policy\": true,\n            \"sections\": {\n                \"authentication_methods\": {\n                    \"allowed_auth_list\": [\n                        \"duo-passcode\",\n                        \"duo-push\",\n                        \"hardware-token\",\n                        \"sms\",\n                        \"webauthn-platform\",\n                        \"webauthn-roaming\"\n                    ],\n                    \"auto_retry_sms\": false,\n                    \"blocked_auth_list\": [],\n                    \"require_verified_push\": true,\n                    \"verified_push_digits\": 6\n                }\n         }\n}"
						},
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "This folder contains the request necessary for mass policy enforcement across all Duo child accounts beneath a Duo MSP tenant using the list of account IDs in duoChildAccounts.\n\n- **Customizing Policy Options:**\n    \n    - Navigate to the Body tab of the 'Update Global Policy' request.\n        \n    - Modify the [Policy Section Data](https://duo.com/docs/adminapi#policy-section-data) to align with your desired security policies.\n        \n        - **Note:** Refer to the documentation on Policy Section Data for insight into configuring policy options.\n            \n- **Execution:**\n    \n    - After customizing the policy section data to your desired configuration, execute the 'Update Global Policy' request to enforce the policy across all accounts.\n        \n        - This process iterates over each ID in your `duoChildAccounts`, applying the newly configured global policy settings to all your Duo child accounts.\n            \n            - **Note:** Ensure that the configured policies meet the security requirements of your organization before executing the request.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"// Get HMAC 1",
							"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
							"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
							"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
							"",
							"    // Check if the API hostname is defined. If not, throw an error.",
							"    if (!API_HOSTNAME) {",
							"        throw new Error(\"API_HOSTNAME is not defined\");",
							"    }",
							"     ",
							"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
							"    if (requestUrl.indexOf(\"?\") == -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    // Get the index of the start of the query parameters in the URL ",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"",
							"    // Calculate the length of the hostname",
							"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
							"",
							"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
							"     ",
							"    // Clean up api_call by removing any unwanted characters",
							"    api_call = api_call.replace(\"}}\", \"\");",
							"    // console.log('api_call:', api_call);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"    //Create unsorted array of parameters from either URL or Body",
							"    //Assuming POST parameters are in the Body, GET paramters are in URL",
							"    //(technically it looks like POST can be in the URL as well)",
							"",
							"    // Depending on the HTTP method and the existence of a request body,",
							"    // extract the query parameters from the URL or the body into params_array",
							"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
							"        for (var parameter1 in requestBody) {",
							"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart+1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"     ",
							"    params_array.sort();                    //lexicographically sort parameters by key",
							"    var encoded_params = \"\";               ",
							"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
							"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
							"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
							"    }",
							"     ",
							"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\",timestamp);",
							" ",
							"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
							"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
							"    // console.log(requestData);",
							" ",
							"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
							"    var CryptoJS = require('crypto-js');",
							"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
							"     ",
							"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
							"    var prebase = IKEY+\":\"+ hmacDigest;",
							"    // console.log(\"prebase:\", prebase)",
							"     ",
							"    //encodes a string in base-64",
							"    var btoa = require('btoa');",
							"    var baseComplete = btoa(prebase);",
							"",
							"    var authHeader = \"Basic \"+ baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"// Get HMAC 2",
							"function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
							"",
							"    if (requestUrl.indexOf(\"?\") === -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"",
							"    // Check if requestBody is not empty",
							"    if (Object.keys(requestBody).length !== 0) {",
							"        var jsonDataString = JSON.stringify(requestBody);",
							"        jsonDataString = replaceAllVariables(jsonDataString);",
							"        requestBody = JSON.parse(jsonDataString);",
							"        for (var parameter in requestBody) {",
							"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart + 1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"",
							"    params_array.sort();",
							"    var encoded_params = \"\";",
							"    if (params_array[0] !== \"\") {",
							"        var encoded_params_array = params_array.map(urlEncodeParams);",
							"        encoded_params = encoded_params_array.join(\"&\");",
							"    }",
							"",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\", timestamp);",
							"",
							"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
							"    if (Object.keys(requestBody).length !== 0) {",
							"        requestData += \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
							"    } else {",
							"        requestData += \"\\n\" + CryptoJS.SHA512(\"\") + \"\\n\" + CryptoJS.SHA512(\"\");",
							"    }",
							"",
							"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
							"",
							"    var prebase = IKEY + \":\" + hmacDigest;",
							"    var baseComplete = btoa(prebase);",
							"    var authHeader = \"Basic \" + baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"function urlEncodeParams(value, index, array) {",
							"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
							"}",
							"",
							"function replaceAllVariables(str) {",
							"    var variableRegex = /\\{\\{(\\w+)\\}\\}/g;",
							"    return str.replace(variableRegex, function(match, variableName) {",
							"        return pm.variables.get(variableName);",
							"    });",
							"}",
							"",
							"// Request 1 - Get Accounts",
							"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
							"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
							"",
							"    pm.sendRequest({",
							"    url: url1,",
							"    method: \"POST\",",
							"    header: {",
							"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"        \"Date\": pm.globals.get(\"timestampHeader\")",
							"    },",
							"    body: {}",
							"    }, function(err, res) {",
							"    if (err) {",
							"        console.log(\"Error:\", err);",
							"        return;",
							"    }",
							"",
							"    try {",
							"        var responseJson = JSON.parse(res.text());",
							"        if (responseJson.stat === \"OK\") {",
							"            var duoChildAccounts = {};",
							"            responseJson.response.forEach(function(account) {",
							"                duoChildAccounts[account.account_id] = {",
							"                    name: account.name,",
							"                    apiHostname: account.api_hostname",
							"                };",
							"            });",
							"",
							"            pm.collectionVariables.set(\"duoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"",
							"            // Now that duoChildAccounts is set, start processing each account",
							"            var keys = Object.keys(duoChildAccounts);",
							"            processAccount(keys, 0, duoChildAccounts);",
							"        } else {",
							"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
							"        }",
							"    } catch (error) {",
							"        console.log(\"Error parsing JSON:\", error);",
							"    }",
							"});",
							"",
							"function processAccount(keys, index, DuoChildAccounts) {",
							"    if (index >= keys.length) {",
							"        // console.log(\"All accounts have been processed\");",
							"",
							"        // Remove the specified variables",
							"        pm.globals.unset(\"timestampHeader\");",
							"        pm.globals.unset(\"hmacAuthHeader\");",
							"        pm.globals.unset(\"next_offset\");",
							"        return;",
							"    }",
							"",
							"    let accountId = keys[index];",
							"    if (accountId && accountId.trim() !== \"\" && DuoChildAccounts[accountId]) {",
							"        var accountDetails = DuoChildAccounts[accountId];",
							"        var accountName = accountDetails.name;",
							"        var apiHostname = accountDetails.apiHostname;",
							"",
							"        var urlWithAccountId = `https://${apiHostname}/admin/v2/policies?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
							"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"GET\", urlWithAccountId, {}, apiHostname));",
							"",
							"        pm.sendRequest({",
							"            url: urlWithAccountId,",
							"            method: \"GET\",",
							"            header: {",
							"                \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"                \"Date\": pm.globals.get(\"timestampHeader\")",
							"            },",
							"            body: {}",
							"        }, function(err, res) {",
							"            if (err) {",
							"                console.error('Error for account:', accountName, '; Error:', err);",
							"                processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account in case of an error",
							"                return;",
							"            }",
							"",
							"            if (res.code === 200) {",
							"                var resJson = res.json();",
							"                var policies = resJson.response || [];",
							"",
							"                var globalPolicy = policies.find(policy => policy.is_global_policy);",
							"                if (globalPolicy) {",
							"                    DuoChildAccounts[accountId].globalPolicyKey = globalPolicy.policy_key;",
							"                    pm.collectionVariables.set(\"duoChildAccounts\", JSON.stringify(DuoChildAccounts));",
							"                }",
							"",
							"                if (resJson.metadata && resJson.metadata.next_offset) {",
							"                    pm.globals.set('next_offset', resJson.metadata.next_offset);",
							"                    processAccount(keys, index, DuoChildAccounts); // Continue with the same account",
							"                } else {",
							"                    pm.globals.set('next_offset', 0);",
							"                    processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account",
							"                }",
							"            } else {",
							"                console.error('Request failed for account:', accountName, '; Response:', res);",
							"                processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account in case of a failed request",
							"            }",
							"        });",
							"    } else {",
							"        console.error('Invalid or missing account details for accountId:', accountId);",
							"        processAccount(keys, index + 1, DuoChildAccounts); // Move to the next account if current is invalid",
							"    }",
							"}",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"// // Parse the response as JSON",
							"// var responseJson = pm.response.json();",
							"",
							"// // Extract the account IDs and account names, and store them in arrays",
							"// var accountIds = [];",
							"// var accountNames = [];",
							"// var duoChildAccounts = {};",
							"",
							"// for (var i = 0; i < responseJson.response.length; i++) {",
							"//   var accountId = responseJson.response[i].account_id;",
							"//   var accountName = responseJson.response[i].name;",
							"  ",
							"//   accountIds.push(accountId);",
							"//   accountNames.push(accountName);",
							"  ",
							"//   duoChildAccounts[accountId] = accountName;",
							"// }",
							"",
							"// pm.globals.set(\"ChildAccountIds\", JSON.stringify(accountIds));",
							"// pm.globals.set(\"ChildAccountNames\", JSON.stringify(accountNames));",
							"",
							"// // Save the mapping object as a global variable",
							"// pm.globals.set(\"DuoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"",
							"// var accountIds = JSON.parse(pm.globals.get(\"ChildAccountIds\"));",
							"// var totalAccounts = accountIds.length;",
							"// var statusCode = responseJson.stat;"
						]
					}
				}
			]
		},
		{
			"name": "Push Phish Simulator",
			"item": [
				{
					"name": "Create Auth API [Push Phish]",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Checks for an existing entry in child_auth_api_matrix",
									"function checkAndUpdateForExistingAccount() {",
									"    const accountName = pm.collectionVariables.get(\"child_account_name\");",
									"    const currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"",
									"    if (currentMatrix) {",
									"        const matrixArray = JSON.parse(currentMatrix);",
									"        const existingEntry = matrixArray.find(entry => entry.accountName === accountName);",
									"",
									"        if (existingEntry) {",
									"            // Update collection variables with the details from the existing entry",
									"            pm.collectionVariables.set(\"child_account_account_id\", existingEntry.accountId);",
									"            pm.collectionVariables.set(\"child_auth_api_ikey\", existingEntry.integrationKey);",
									"            pm.collectionVariables.set(\"child_auth_api_skey\", existingEntry.secretKey);",
									"            pm.collectionVariables.set(\"child_auth_api_host\", existingEntry.apiHostname);",
									"",
									"            var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"            console.log(`Auth API [Push Phish] already exists on ${childAccountName} and is available for use.`);",
									"            return true;",
									"        }",
									"    }",
									"    // Return false if no existing entry was found",
									"    return false;",
									"}",
									"",
									"// If found, updates collection variables with the associated request credentials",
									"if (checkAndUpdateForExistingAccount()) { } else {",
									"",
									"    //HMAC 1",
									"    function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"        var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"        var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"        var API_HOSTNAME = pm.globals.get(\"accounts_api_host\");",
									"        var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
									"",
									"        // Check if the API hostname is defined. If not, throw an error.",
									"        if (!API_HOSTNAME) {",
									"            throw new Error(\"API_HOSTNAME is not defined\");",
									"        }",
									"",
									"        //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
									"        if (requestUrl.indexOf(\"?\") == -1) {",
									"            requestUrl += \"?\";",
									"        }",
									"",
									"        // Get the index of the start of the query parameters in the URL ",
									"        var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"        // Calculate the length of the hostname",
									"        var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"        // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
									"        var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
									"",
									"        // Clean up api_call by removing any unwanted characters",
									"        api_call = api_call.replace(\"}}\", \"\");",
									"        // console.log('api_call:', api_call);",
									"",
									"        var params_unsorted = \"\";",
									"        var params_array = [];",
									"        //Create unsorted array of parameters from either URL or Body",
									"        //Assuming POST parameters are in the Body, GET paramters are in URL",
									"        //(technically it looks like POST can be in the URL as well)",
									"",
									"        // Depending on the HTTP method and the existence of a request body,",
									"        // extract the query parameters from the URL or the body into params_array",
									"        if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"            for (var parameter1 in requestBody) {",
									"                params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"                params_array.push(params_unsorted);",
									"            }",
									"        } else {",
									"            params_unsorted = requestUrl.substring(paramsStart + 1);",
									"            params_array = params_unsorted.split(\"&\");",
									"        }",
									"",
									"        params_array.sort();                    //lexicographically sort parameters by key",
									"        var encoded_params = \"\";",
									"        if (params_array[0] !== \"\") { //check if there are any Params to encode and create the string from",
									"            var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
									"            encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
									"        }",
									"",
									"        // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
									"        var moment = require('moment');",
									"        var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"        pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"        // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
									"        var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + API_HOSTNAME + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"        // console.log(requestData);",
									"",
									"        // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
									"        var CryptoJS = require('crypto-js');",
									"        var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"",
									"        //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
									"        var prebase = IKEY + \":\" + hmacDigest;",
									"        // console.log(\"prebase:\", prebase)",
									"",
									"        //encodes a string in base-64",
									"        var btoa = require('btoa');",
									"        var baseComplete = btoa(prebase);",
									"",
									"        var authHeader = \"Basic \" + baseComplete;",
									"        return authHeader;",
									"    }",
									"",
									"    // HMAC 2",
									"    function getAuthHeader2(httpMethod, requestUrl, requestBody, apiHostname) {",
									"        var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"        var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"        if (requestUrl.indexOf(\"?\") === -1) {",
									"            requestUrl += \"?\";",
									"        }",
									"",
									"        var paramsStart = requestUrl.indexOf(\"?\");",
									"        var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"        var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"        var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        var params_array = params_unsorted.split(\"&\");",
									"        params_array.sort();",
									"        var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"        var moment = require('moment');",
									"        var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"        pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"        var jsonDataString = JSON.stringify(requestBody);",
									"        var CryptoJS = require('crypto-js');",
									"        var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"        var CryptoJS = require('crypto-js');",
									"        var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"        var prebase = IKEY + \":\" + hmacDigest;",
									"        var btoa = require('btoa');",
									"        var baseComplete = btoa(prebase);",
									"        var authHeader = \"Basic \" + baseComplete;",
									"        return authHeader;",
									"    }",
									"",
									"    function urlEncodeParams(value) {",
									"        return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"    }",
									"",
									"    // Request 1 - Get Accounts",
									"    function getAccounts() {",
									"        var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
									"",
									"        pm.sendRequest({",
									"            url: url1,",
									"            method: \"POST\",",
									"            header: {",
									"                \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"                \"Date\": pm.globals.get(\"timestampHeader\")",
									"            },",
									"            body: {}",
									"        }, function (err, res) {",
									"            if (err) {",
									"                console.log(\"Error:\", err);",
									"                return;",
									"            }",
									"",
									"            var responseJson = JSON.parse(res.text());",
									"            if (responseJson.stat === \"OK\") {",
									"                // Logic to set child_account_account_id and child_auth_api_host",
									"                handleGetAccountsResponse(responseJson);",
									"            } else {",
									"                console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
									"            }",
									"        });",
									"    }",
									"",
									"    // Handler for Get Accounts response",
									"    function handleGetAccountsResponse(responseJson) {",
									"        // Extract relevant data from responseJson and set collection variables",
									"        var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"        var foundAccount = responseJson.response.find(acc => acc.name === childAccountName);",
									"",
									"        if (foundAccount) {",
									"            pm.collectionVariables.set(\"child_account_account_id\", foundAccount.account_id);",
									"            pm.collectionVariables.set(\"child_auth_api_host\", foundAccount.api_hostname);",
									"",
									"",
									"            // Proceed with Request 2 - Create Integration",
									"            createIntegration(foundAccount.api_hostname, foundAccount.account_id);",
									"        } else {",
									"            console.log(`No matching account found for ${childAccountName}.`);",
									"        }",
									"    }",
									"",
									"    // Request 2 - Create Integration",
									"    function createIntegration(apiHostname, accountId) {",
									"        var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"",
									"        // Ensure accountId is available",
									"        if (!accountId) {",
									"            console.log(\"Account ID is not set. Stopping execution.\");",
									"            return;",
									"        }",
									"",
									"        // Pre-check for existing integration in child_auth_api_matrix",
									"        var currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"        currentMatrix = currentMatrix ? JSON.parse(currentMatrix) : [];",
									"        var existingEntry = currentMatrix.find(entry => entry.accountName === childAccountName && entry.accountId === accountId);",
									"",
									"        if (existingEntry) {",
									"            console.log(`Duo Auth API [Push Phish] already exists for ${childAccountName} and is available for use.`);",
									"            // Optionally, you can call retrieveSecretKey or any other function here if needed.",
									"            return;",
									"        }",
									"",
									"        var urlWithAccountId = `https://${apiHostname}/admin/v2/integrations?account_id=${accountId}`;",
									"        var requestBody = {",
									"            \"name\": \"Auth API [Push Phish]\",",
									"            \"type\": \"authapi\"",
									"        };",
									"",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"POST\", urlWithAccountId, requestBody, apiHostname));",
									"",
									"        pm.sendRequest({",
									"            url: urlWithAccountId,",
									"            method: \"POST\",",
									"            header: {",
									"                \"Content-Type\": \"application/json\",",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"                \"Date\": pm.globals.get(\"timestampHeader\")",
									"            },",
									"            body: {",
									"                mode: 'raw',",
									"                raw: JSON.stringify(requestBody)",
									"            }",
									"        }, function (err, res) {",
									"            if (err) {",
									"                console.error('Network error:', err);",
									"                return;",
									"            }",
									"            var responseData = res.json();",
									"            if (res.code === 200) {",
									"                var integrationKey = responseData.response.integration_key;",
									"                pm.collectionVariables.set(\"child_auth_api_ikey\", integrationKey);",
									"",
									"",
									"                // Update matrix and proceed to retrieve the secret key",
									"                // updateMatrix(accountId, childAccountName, integrationKey, pm.collectionVariables.get(\"child_auth_api_skey\"), apiHostname);",
									"",
									"                retrieveSecretKey(apiHostname, integrationKey, accountId);",
									"            } else {",
									"                console.error(`Request 2 failed. HTTP status code: ${res.code}; Response:`, responseData);",
									"            }",
									"        });",
									"    }",
									"",
									"    // Request 3 - Retrieve Secret Key",
									"    function retrieveSecretKey(apiHostname, integrationKey, accountId) {",
									"        // Retrieve childAccountName within this function to ensure it's defined",
									"        var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
									"        if (!accountId) {",
									"            console.log(\"Account ID is not provided. Stopping execution.\");",
									"            return;",
									"        }",
									"        if (!childAccountName) {",
									"            console.log(\"Child Account Name is not provided. Stopping execution.\");",
									"            return;",
									"        }",
									"",
									"        var urlWithAccountId2 = `https://${apiHostname}/admin/v1/integrations/${integrationKey}/skey?account_id=${accountId}`;",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader2(\"GET\", urlWithAccountId2, {}, apiHostname));",
									"",
									"        pm.sendRequest({",
									"            url: urlWithAccountId2,",
									"            method: \"GET\",",
									"            header: {",
									"                \"Content-Type\": \"application/json\",",
									"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"                \"Date\": pm.globals.get(\"timestampHeader\")",
									"            },",
									"            body: {",
									"                mode: 'raw',",
									"                raw: JSON.stringify({})",
									"            }",
									"        }, function (err, res) {",
									"            if (err) {",
									"                console.error('Network error on the second request:', err);",
									"            } else {",
									"                var responseData = res.json();",
									"                if (res.code === 200) {",
									"                    var secretKey = responseData.response.secret_key;",
									"                    pm.collectionVariables.set(\"child_auth_api_skey\", secretKey);",
									"                    updateMatrix(accountId, childAccountName, integrationKey, secretKey, apiHostname);",
									"                    console.log(`Auth API [Push Phish] created successfully on ${childAccountName} and is available for use.`);",
									"                } else {",
									"                    console.error(`Second request failed. Response code: ${res.code}; Response:`, responseData);",
									"                }",
									"            }",
									"        });",
									"    }",
									"",
									"    function updateMatrix(accountId, childAccountName, integrationKey, secretKey, apiHostname) {",
									"        var currentMatrix = pm.collectionVariables.get(\"child_auth_api_matrix\");",
									"        currentMatrix = currentMatrix ? JSON.parse(currentMatrix) : [];",
									"        currentMatrix.push({",
									"            accountId: accountId,",
									"            accountName: childAccountName,",
									"            integrationKey: integrationKey,",
									"            secretKey: secretKey,",
									"            apiHostname: apiHostname",
									"        });",
									"        pm.collectionVariables.set(\"child_auth_api_matrix\", JSON.stringify(currentMatrix));",
									"    }",
									"",
									"    // Make sure getAccounts function is defined somewhere above this snippet",
									"    getAccounts();",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Retrieve Push Phish Users",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Get HMAC authentication header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
									"    var AUTH_TYPE = 'HMAC-SHA1';",
									"",
									"    if (requestUrl.indexOf(\"?\") == -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"",
									"    if (Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"",
									"    params_array.sort();",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value, index, array) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Replace duoChildAccounts and processAccount function with direct request",
									"var apiHostname = pm.collectionVariables.get(\"child_auth_api_host\"); // Get the apiHostname from the collection variable",
									"var accountId = pm.collectionVariables.get(\"child_account_account_id\"); // Get the accountId from the collection variable",
									"",
									"// Update the URL to use the specific apiHostname and accountId",
									"var urlWithAccountId = `https://${apiHostname}/admin/v1/users?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;",
									"",
									"// Generate the HMAC header using the specific apiHostname",
									"var hmacAuthHeader = getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname);",
									"",
									"pm.sendRequest({",
									"    url: urlWithAccountId,",
									"    method: \"GET\",",
									"    header: {",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"        \"Authorization\": hmacAuthHeader,",
									"        \"Date\": pm.globals.get(\"timestampHeader\")",
									"    },",
									"    body: {}",
									"}, function (err, res) {",
									"    if (err) {",
									"        console.error('Request failed; Error:', err);",
									"    } else {",
									"        // console.log('Request successful; Response:', res.json());",
									"",
									"        // Process the response to filter users part of the group specified in the \"pushPhishGroup\" collection variable and format them in CSV",
									"",
									"        let groupName = pm.collectionVariables.get(\"pushPhishGroup\"); // Retrieve the group name from collection variable",
									"        if (!groupName) {",
									"            console.log('Please add a group to the pushPhishGroup collection variable, and run the request again.');",
									"            return;",
									"        }",
									"",
									"        let response = res.json();",
									"        let users = response.response;",
									"        let pushUsersCsv = 'username\\n'; // CSV header",
									"",
									"        users.forEach(user => {",
									"            let groups = user.groups;",
									"            let isMemberOfSpecifiedGroup = groups.some(group => group.name === groupName);",
									"",
									"            if (isMemberOfSpecifiedGroup) {",
									"                pushUsersCsv += `${user.username}\\n`; // Add username to CSV string",
									"            }",
									"        });",
									"",
									"        // Assume 'pushUsersCsv' and 'groupName' variables are defined and contain appropriate values",
									"",
									"// Update the collection variable with CSV data",
									"pm.collectionVariables.set(\"pushPhishusersCsv\", pushUsersCsv);",
									"",
									"// Log the update to the console for confirmation",
									"console.log(`Updated the pushPhishusersCsv collection variable with the users from the ${groupName} group:`);",
									"",
									"console.log(\"Please run the 'Execute Push Phish' request to send a Duo push request to the identified users.\");",
									"",
									"    }",
									"});",
									"",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Execute Push Phish",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// // Parse the JSON response",
									"// const jsonResponse = pm.response.json();",
									"",
									"// // Check if the \"stat\" value is \"OK\"",
									"// if (jsonResponse.stat === \"OK\") {",
									"//     // Log a message in the console",
									"//     console.log(\"Successfully performed second-factor authentication for specified useror sent the user a new batch of passcodes via SMS.\");",
									"// } else {",
									"//     console.log(\"Invalid or missing parameters. Verify all the set parameters are correct for the user.\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.collectionVariables.get(\"child_auth_api_ikey\"); // Use Auth API IKEY",
									"    var SKEY = pm.collectionVariables.get(\"child_auth_api_skey\"); // Use Auth API SKEY",
									"    var API_HOSTNAME = pm.collectionVariables.get(\"child_auth_api_host\"); // Use Auth API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA512'; // Authentication type, though not directly used in the code, denotes the algorithm for HMAC",
									"",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart).replace(\"}}\", \"\");",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter in requestBody) {",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"    params_array.sort();",
									"    ",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + API_HOSTNAME + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"",
									"pm.collectionVariables.set(\"phish_auth_status\", JSON.stringify([]));",
									"",
									"",
									"// Retrieve the pushPhishusersCsv variable and split it into an array of usernames",
									"var users = pm.collectionVariables.get(\"pushPhishusersCsv\").split(\"\\n\");",
									"",
									"users.slice(1).forEach(function(user) {",
									"    if (user.trim() === \"\") return; // Skip empty lines or invalid usernames",
									"",
									"    var url = `https://${pm.collectionVariables.get(\"child_auth_api_host\")}/auth/v2/auth?username=${user.trim()}&factor=auto&device=auto&async=1`;",
									"",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url, {}));",
									"",
									"    pm.sendRequest({",
									"    url: url,",
									"    method: \"POST\",",
									"    header: {",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"        \"Date\": pm.globals.get(\"timestampHeader\")",
									"    },",
									"    body: {}",
									"    }, function(err, res) {",
									"    if (err) {",
									"        console.error('Request failed; Error:', err);",
									"    } else {",
									"        let response = res.json(); // Parse the JSON response",
									"        // Assuming response contains the required txid and stat OK",
									"        if (response.stat === \"OK\" && response.response && response.response.txid) {",
									"            // Retrieve the existing phish_auth_status or initialize if not present",
									"            let phishAuthStatus = JSON.parse(pm.collectionVariables.get(\"phish_auth_status\") || \"[]\");",
									"            // Add the current user and txid to the array",
									"            phishAuthStatus.push({ username: user.trim(), txid: response.response.txid });",
									"            // Update the collection variable with the new array",
									"            pm.collectionVariables.set(\"phish_auth_status\", JSON.stringify(phishAuthStatus));",
									"            console.log(`Push phish sent successfully to ${user.trim()}`);",
									"        }",
									"    }",
									"    });",
									"})"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "ipaddr",
									"value": "",
									"description": "Optional: The IP address of the user to be authenticated, in dotted quad format. This will cause an \"allow\" response to be sent if appropriate for requests from a trusted network.",
									"disabled": true
								},
								{
									"key": "hostname",
									"value": "",
									"description": "Optional: The host name of the device accessing the application.",
									"disabled": true
								},
								{
									"key": "async",
									"value": "",
									"description": "Optional: If this parameter is not provided, then the /auth endpoint will only return a response when the authentication process has completed. If, however, your application provides this parameter with a value of \"1\", then /auth will immediately return a transaction ID, and your application will need to subsequently query the /auth_status endpoint to get the status (and, eventually, result) of the authentication process.\n\nIf you enable async, then your application will be able to retrieve real-time status updates from the authentication process, rather than receiving no information until the process is complete.",
									"disabled": true
								},
								{
									"key": "type",
									"value": "",
									"description": "DUO PUSH - Optional: This string is displayed in the Duo Mobile app push notification and UI. You may wish to specify some alternate phrase for this parameter. The default English string in Duo Mobile v4 is \"Verify your identity\" and \"Are you logging in to\" followed by the application's name in the push request notification text, and \"Are you logging in to\" followed by the application's name in the request details screen as shown in Duo Mobile. With type specified, the notification text changes to \"Verify request\" and shows your customized string followed by a colon and the application's name, and the request details screen also shows your customized string and the application's name. Duo Mobile shows the equivalent localization in the languagues supported by the app, but does not attempt to localize your custom string or support multiple string values (for different languages).\n\nIn Duo Mobile v3, the default string shown is \"Login Request\" followed by the application's name in both the push notification text and on the request details screen.",
									"disabled": true
								},
								{
									"key": "display_username",
									"value": "",
									"description": "DUO PUSH - Optional: String to display in Duo Mobile in place of the user's Duo username.",
									"disabled": true
								},
								{
									"key": "pushinfo",
									"value": "",
									"description": "Optional: A set of URL-encoded key/value pairs with additional contextual information associated with this authentication attempt. The Duo Mobile app will display this information to the user.\n\nFor example: from=login%20portal&domain=example.com\n\nThe URL-encoded string's total length must be less than 20,000 bytes.",
									"disabled": true
								},
								{
									"key": "passcode",
									"value": "",
									"description": "PASSCODE - Required if using passcodes: Passcode entered by the user.",
									"disabled": true
								}
							]
						},
						"description": "TheÂ `/auth`Â endpoint performs second-factor authentication for a user by sending a push notification to the user's smartphone app, verifying a passcode, or placing a phone call. It is also used to send the user a new batch of passcodes via SMS."
					},
					"response": []
				},
				{
					"name": "Retreive Push Phish Report",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// // Parse the JSON response",
									"// const jsonResponse = pm.response.json();",
									"",
									"// // Check if the \"stat\" value is \"OK\"",
									"// if (jsonResponse.stat === \"OK\") {",
									"//     // Log a message in the console",
									"//     console.log(\"Successfully performed second-factor authentication for specified useror sent the user a new batch of passcodes via SMS.\");",
									"// } else {",
									"//     console.log(\"Invalid or missing parameters. Verify all the set parameters are correct for the user.\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    var IKEY = pm.collectionVariables.get(\"child_auth_api_ikey\"); // Use Auth API IKEY",
									"    var SKEY = pm.collectionVariables.get(\"child_auth_api_skey\"); // Use Auth API SKEY",
									"    var API_HOSTNAME = pm.collectionVariables.get(\"child_auth_api_host\"); // Use Auth API Hostname",
									"    var AUTH_TYPE = 'HMAC-SHA512'; // Authentication type, though not directly used in the code, denotes the algorithm for HMAC",
									"",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart).replace(\"}}\", \"\");",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter in requestBody) {",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"    params_array.sort();",
									"    ",
									"    var encoded_params = \"\";",
									"    if (params_array[0] !== \"\") {",
									"        var encoded_params_array = params_array.map(urlEncodeParams);",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + API_HOSTNAME + \"\\n\" + api_call + \"\\n\" + encoded_params;",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"var pushAuthStatus = JSON.parse(pm.collectionVariables.get(\"phish_auth_status\"));",
									"",
									"// Initialize a structure to hold all user authentication details",
									"let authDetails = [];",
									"",
									"pushAuthStatus.forEach(function(authStatus, index, array) {",
									"    var url = `https://${pm.collectionVariables.get(\"child_auth_api_host\")}/auth/v2/auth_status?txid=${authStatus.txid}`;",
									"",
									"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", url, {}));",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"GET\",",
									"        header: {",
									"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
									"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {}",
									"     }, function(err, res) {",
									"        if (err) {",
									"            console.error(`Error for txid: ${authStatus.txid}`, err);",
									"            // Add error info to authDetails for reporting",
									"            authDetails.push({",
									"                username: authStatus.username,",
									"                result: \"Error\",",
									"                status: \"N/A\",",
									"                statusMsg: err.message || \"Unknown error\"",
									"            });",
									"        } else {",
									"            let response = res.json();",
									"            if (response.stat === \"OK\") {",
									"                // Add successful auth info to authDetails for reporting",
									"                authDetails.push({",
									"                    username: authStatus.username,",
									"                    result: response.response.result,",
									"                    status: response.response.status,",
									"                    statusMsg: response.response.status_msg",
									"                });",
									"            }",
									"        }",
									"",
									"        // If it's the last response, generate and log the CSV",
									"        if (index === array.length - 1) {",
									"            generateAndLogCsv(authDetails);",
									"        }",
									"    });",
									"});",
									"",
									"function generateAndLogCsv(authDetails) {",
									"    let csvContent = \"Username,Result,Status,Status Message\\n\"; // CSV header",
									"    authDetails.forEach(detail => {",
									"        csvContent += `${detail.username},${detail.result},${detail.status},${detail.statusMsg}\\n`;",
									"    });",
									"    console.log(csvContent);",
									"}",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "ipaddr",
									"value": "",
									"description": "Optional: The IP address of the user to be authenticated, in dotted quad format. This will cause an \"allow\" response to be sent if appropriate for requests from a trusted network.",
									"disabled": true
								},
								{
									"key": "hostname",
									"value": "",
									"description": "Optional: The host name of the device accessing the application.",
									"disabled": true
								},
								{
									"key": "async",
									"value": "",
									"description": "Optional: If this parameter is not provided, then the /auth endpoint will only return a response when the authentication process has completed. If, however, your application provides this parameter with a value of \"1\", then /auth will immediately return a transaction ID, and your application will need to subsequently query the /auth_status endpoint to get the status (and, eventually, result) of the authentication process.\n\nIf you enable async, then your application will be able to retrieve real-time status updates from the authentication process, rather than receiving no information until the process is complete.",
									"disabled": true
								},
								{
									"key": "type",
									"value": "",
									"description": "DUO PUSH - Optional: This string is displayed in the Duo Mobile app push notification and UI. You may wish to specify some alternate phrase for this parameter. The default English string in Duo Mobile v4 is \"Verify your identity\" and \"Are you logging in to\" followed by the application's name in the push request notification text, and \"Are you logging in to\" followed by the application's name in the request details screen as shown in Duo Mobile. With type specified, the notification text changes to \"Verify request\" and shows your customized string followed by a colon and the application's name, and the request details screen also shows your customized string and the application's name. Duo Mobile shows the equivalent localization in the languagues supported by the app, but does not attempt to localize your custom string or support multiple string values (for different languages).\n\nIn Duo Mobile v3, the default string shown is \"Login Request\" followed by the application's name in both the push notification text and on the request details screen.",
									"disabled": true
								},
								{
									"key": "display_username",
									"value": "",
									"description": "DUO PUSH - Optional: String to display in Duo Mobile in place of the user's Duo username.",
									"disabled": true
								},
								{
									"key": "pushinfo",
									"value": "",
									"description": "Optional: A set of URL-encoded key/value pairs with additional contextual information associated with this authentication attempt. The Duo Mobile app will display this information to the user.\n\nFor example: from=login%20portal&domain=example.com\n\nThe URL-encoded string's total length must be less than 20,000 bytes.",
									"disabled": true
								},
								{
									"key": "passcode",
									"value": "",
									"description": "PASSCODE - Required if using passcodes: Passcode entered by the user.",
									"disabled": true
								}
							]
						},
						"description": "TheÂ `/auth`Â endpoint performs second-factor authentication for a user by sending a push notification to the user's smartphone app, verifying a passcode, or placing a phone call. It is also used to send the user a new batch of passcodes via SMS."
					},
					"response": []
				},
				{
					"name": "Clear Push Phish Variables",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Clear the values of the collection variables",
									"pm.collectionVariables.set(\"pushPhishGroup\", \"\");",
									"pm.collectionVariables.unset(\"child_auth_api_ikey\");",
									"pm.collectionVariables.unset(\"child_auth_api_skey\");",
									"pm.collectionVariables.unset(\"child_auth_api_host\");",
									"pm.collectionVariables.unset(\"pushPhishusersCsv\");",
									"pm.collectionVariables.unset(\"duoChildAccounts\");",
									"pm.collectionVariables.unset(\"phish_auth_status\");",
									"pm.collectionVariables.unset(\"child_account_account_id\");",
									"pm.collectionVariables.unset(\"child_auth_api_matrix\");",
									"pm.collectionVariables.set(\"child_account_name\", \"\");",
									"",
									"// Log a message to confirm the action, specifically formatted as requested",
									"console.log(`Cleared Push Phish collection variables.`);",
									"",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "This folder contains requests to run a Push Phishing simulation, allowing Administrators to send Duo Push reqeusts to a subset of users determine if users understand the importance of only approving authorized Duo Push request.\n\n1. **Set Child Account Name:** Go to the Variables tab in Duo Administrative Tasks and enter the child account name in the `child_account_name` variable to define the desired account.\n2. **Specify Group:** Create or select a group for the test users and add the desired users. Update the `pushPhishGroup` collection variable with the group name.\n3. **Run Requests:** Execute the requests in sequence:\n    \n    1. Create Auth API: Creates an Auth API on the target account\n    2. Retrieve Push Phish Users: Pulls the list of Duo users that belong to the target `pushphishGroup`\n        \n    3. Execute Push Phish: Sends a Duo push requests to the users in the `pushphishGroup`\n        \n        1. Wait about 60 seconds before proceeding to the next step, allowing the requests to be processed before running the push phish report.\n            \n    4. Retrieve Push Phish Report: Outputs the results from the push phish simulation, which includes the username, result, status, and message.\n        \n4. **Clear Variables:** Finish by running \"Clear Push Phish Variables\" to reset the values used during the simulation."
		},
		{
			"name": "Universal Prompt",
			"item": [
				{
					"name": "Retrieve V4 Integrations (V2)",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Variable Declaration\r",
									"var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
									"\r",
									"// Get HMAC authentication header\r",
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
									"\r",
									"    if (requestUrl.indexOf(\"?\") === -1) {\r",
									"        requestUrl += \"?\";\r",
									"    }\r",
									"\r",
									"    var paramsStart = requestUrl.indexOf(\"?\");\r",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8\r",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
									"\r",
									"    var params_unsorted = \"\";\r",
									"    var params_array = [];\r",
									"\r",
									"    // Check if requestBody is not empty\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        var jsonDataString = JSON.stringify(requestBody);\r",
									"        jsonDataString = replaceAllVariables(jsonDataString);\r",
									"        requestBody = JSON.parse(jsonDataString);\r",
									"        for (var parameter in requestBody) {\r",
									"            params_unsorted = parameter + \"=\" + requestBody[parameter];\r",
									"            params_array.push(params_unsorted);\r",
									"        }\r",
									"    } else {\r",
									"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
									"        params_array = params_unsorted.split(\"&\");\r",
									"    }\r",
									"\r",
									"    params_array.sort();\r",
									"    var encoded_params = \"\";\r",
									"    if (params_array[0] !== \"\") {\r",
									"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
									"        encoded_params = encoded_params_array.join(\"&\");\r",
									"    }\r",
									"\r",
									"    var moment = require('moment');\r",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
									"    pm.globals.set(\"timestampHeader\", timestamp);\r",
									"\r",
									"    var CryptoJS = require('crypto-js');\r",
									"\r",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
									"    if (Object.keys(requestBody).length !== 0) {\r",
									"        requestData += \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");\r",
									"    } else {\r",
									"        requestData += \"\\n\" + CryptoJS.SHA512(\"\") + \"\\n\" + CryptoJS.SHA512(\"\");\r",
									"    }\r",
									"\r",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);\r",
									"\r",
									"    var prebase = IKEY + \":\" + hmacDigest;\r",
									"    var btoa = require('btoa');\r",
									"    var baseComplete = btoa(prebase);\r",
									"    var authHeader = \"Basic \" + baseComplete;\r",
									"    return authHeader;\r",
									"}\r",
									"\r",
									"function urlEncodeParams(value, index, array) {\r",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
									"}\r",
									"\r",
									"function replaceAllVariables(str) {\r",
									"    var variableRegex = /\\{\\{(\\w+)\\}\\}/g;\r",
									"    return str.replace(variableRegex, function(match, variableName) {\r",
									"        return pm.variables.get(variableName);\r",
									"    });\r",
									"}\r",
									"\r",
									"var keys = Object.keys(DuoChildAccounts);\r",
									"processAccount(keys, 0);\r",
									"\r",
									"// Before the processAccount function declaration\r",
									"var universal_prompt_ikeys = {};\r",
									"\r",
									"\r",
									"function processAccount(keys, index) {\r",
									"    if (index >= keys.length) {\r",
									"        // All accounts have been processed\r",
									"        return;\r",
									"    }\r",
									"\r",
									"    let accountId = keys[index];\r",
									"    if (accountId && accountId.trim() !== \"\") {\r",
									"        pm.globals.set(\"accountId\", accountId);\r",
									"        var accountDetails = DuoChildAccounts[accountId];\r",
									"        var accountName = accountDetails.name;\r",
									"        var apiHostname = accountDetails.apiHostname; // Get the apiHostname for the current account\r",
									"\r",
									"        // Update the URL to use the specific apiHostname\r",
									"        var urlWithAccountId = `https://${apiHostname}/admin/v2/integrations?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;\r",
									"\r",
									"        // Generate the HMAC header using the specific apiHostname\r",
									"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname));\r",
									"\r",
									"        pm.sendRequest({\r",
									"    url: urlWithAccountId,\r",
									"    method: \"GET\",\r",
									"    header: {\r",
									"        \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
									"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
									"        \"Date\": pm.globals.get(\"timestampHeader\")\r",
									"    },\r",
									"    body: {}\r",
									"}, function(err, res) {\r",
									"    if (res.code === 200) {\r",
									"        var resJson = res.json();\r",
									"        var users = resJson.response || [];\r",
									"\r",
									"        users.forEach(function(integration) {\r",
									"            if (integration.frameless_auth_prompt_enabled === 1 && integration.type !== 'sso-generic') {\r",
									"                // Check if the account entry is already created, if not initialize it\r",
									"                if (!universal_prompt_ikeys[accountId]) {\r",
									"                    universal_prompt_ikeys[accountId] = {\r",
									"                        accountName: accountName,\r",
									"                        apiHostname: apiHostname, // Store the API hostname here\r",
									"                        integrationKeys: []\r",
									"                    };\r",
									"                }\r",
									"                // No need to check for duplicate integration keys as we assume they are unique per account\r",
									"                universal_prompt_ikeys[accountId].integrationKeys.push(integration.integration_key);\r",
									"            }\r",
									"        });\r",
									"\r",
									"         pm.collectionVariables.set(\"universal_prompt_ikeys\", JSON.stringify(universal_prompt_ikeys));\r",
									"\r",
									"        if (resJson.metadata && resJson.metadata.next_offset) {\r",
									"            pm.globals.set('next_offset', resJson.metadata.next_offset);\r",
									"            processAccount(keys, index);\r",
									"        } else {\r",
									"            pm.globals.set('next_offset', 0);\r",
									"            processAccount(keys, index + 1);\r",
									"        }\r",
									"    } else {\r",
									"        console.error('Request failed for account:', accountName, '; Error:', err, '; Response:', res);\r",
									"        processAccount(keys, index + 1);\r",
									"    }\r",
									"}); // Correctly closes the pm.sendRequest call\r",
									"} // Correctly closes the if (accountId && accountId.trim() !== \"\") block\r",
									"} // Correctly closes the processAccount function"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.globals.unset(\"timestampHeader\");",
									"    pm.globals.unset(\"hmacAuthHeader\");",
									"    pm.globals.unset(\"accountId\");",
									"    pm.globals.unset(\"next_offset\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/x-www-form-urlencoded"
							},
							{
								"key": "Date",
								"value": "{{timestampHeader}}"
							},
							{
								"key": "Authorization",
								"value": "{{hmacAuthHeader}}"
							}
						],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							],
							"query": [
								{
									"key": "",
									"value": "",
									"disabled": true
								}
							]
						},
						"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
					},
					"response": []
				},
				{
					"name": "Enable Universal Prompt",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\");",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\");",
									"",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"    var hostname_length = apiHostname.length + 8; // Length of 'https://' is 8",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"",
									"    var params_unsorted = requestUrl.substring(paramsStart + 1);",
									"    var params_array = params_unsorted.split(\"&\");",
									"    params_array.sort();",
									"    var encoded_params = params_array.map(urlEncodeParams).join(\"&\");",
									"",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\", timestamp);",
									"",
									"    var CryptoJS = require('crypto-js');",
									"",
									"    var jsonDataString = JSON.stringify(requestBody);",
									"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params + \"\\n\" + CryptoJS.SHA512(jsonDataString) + \"\\n\" + CryptoJS.SHA512(\"\");",
									"",
									"    var hmacDigest = CryptoJS.HmacSHA512(requestData, SKEY);",
									"",
									"    var prebase = IKEY + \":\" + hmacDigest;",
									"    var btoa = require('btoa');",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \" + baseComplete;",
									"    return authHeader;",
									"}",
									"",
									"function urlEncodeParams(value) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"function updateIntegrationsForAllAccounts() {",
									"    const universalPromptIkeysStr = pm.collectionVariables.get(\"universal_prompt_ikeys\");",
									"    if (!universalPromptIkeysStr) {",
									"        console.log(\"No universal_prompt_ikeys found. Exiting.\");",
									"        return;",
									"    }",
									"    const universalPromptIkeys = JSON.parse(universalPromptIkeysStr);",
									"",
									"    Object.keys(universalPromptIkeys).forEach(accountId => {",
									"        const accountInfo = universalPromptIkeys[accountId];",
									"        const accountName = accountInfo.accountName; // Assuming account name is needed for logging or other purposes",
									"        const integrationKeys = accountInfo.integrationKeys;",
									"        const apiHostname = accountInfo.apiHostname; // Retrieve the apiHostname for each account from universal_prompt_ikeys",
									"",
									"        integrationKeys.forEach(integrationKey => {",
									"            createOrUpdateIntegration(apiHostname, accountId, integrationKey);",
									"        });",
									"    });",
									"}",
									"",
									"function createOrUpdateIntegration(apiHostname, accountId, integrationKey) {",
									"    const url = `https://${apiHostname}/admin/v2/integrations/${integrationKey}?account_id=${accountId}`;",
									"    const requestBody = {",
									"        \"prompt_v4_enabled\": 1",
									"    };",
									"",
									"    const authHeader = getAuthHeader(\"POST\", url, requestBody, apiHostname);",
									"",
									"    pm.sendRequest({",
									"        url: url,",
									"        method: \"POST\",",
									"        header: {",
									"            \"Content-Type\": \"application/json\",",
									"            \"Authorization\": authHeader,",
									"            \"Date\": pm.globals.get(\"timestampHeader\")",
									"        },",
									"        body: {",
									"            mode: 'raw',",
									"            raw: JSON.stringify(requestBody)",
									"        }",
									"    }, function(err, res) {",
									"        if (err) {",
									"            console.error(`Network error for account ${accountId} and integration ${integrationKey}:`, err);",
									"            return;",
									"        }",
									"        if (res.code === 200 || res.code === 201) {",
									"            console.log(`Universal Prompt updated for account ${accountId} and integration ${integrationKey}`);",
									"        } else {",
									"            console.error(`Request failed for account ${accountId} and integration ${integrationKey}. HTTP status code: ${res.code}; Response:`, res.json());",
									"        }",
									"    });",
									"}",
									"",
									"// Trigger the update process",
									"updateIntegrationsForAllAccounts();",
									"pm.collectionVariables.unset(\"universal_prompt_ikeys\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{duo_url}}",
							"host": [
								"{{duo_url}}"
							]
						}
					},
					"response": []
				}
			],
			"description": "The requests in this folder automates the updating of in scope applications to the Universal Prompt across the full list of child accounts.\n\nIt involves two key steps:\n\n1. **Retrieve V4 Integrations**: This step iterates over the list child account IDs to identify and collect applications eligible for the Universal Prompt update. These applications are stored in a variable (universal_prompt_ikeys), mapped by account ID, account name, and integration keys.\n2. **Enable Universal Prompt**: The next step takes the identified integration keys and activates the Universal Prompt for the in scope applications across each Duo child account.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
							"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
							"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
							"",
							"    // Check if the API hostname is defined. If not, throw an error.",
							"    if (!API_HOSTNAME) {",
							"        throw new Error(\"API_HOSTNAME is not defined\");",
							"    }",
							"     ",
							"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
							"    if (requestUrl.indexOf(\"?\") == -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    // Get the index of the start of the query parameters in the URL ",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"",
							"    // Calculate the length of the hostname",
							"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
							"",
							"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
							"     ",
							"    // Clean up api_call by removing any unwanted characters",
							"    api_call = api_call.replace(\"}}\", \"\");",
							"    // console.log('api_call:', api_call);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"    //Create unsorted array of parameters from either URL or Body",
							"    //Assuming POST parameters are in the Body, GET paramters are in URL",
							"    //(technically it looks like POST can be in the URL as well)",
							"",
							"    // Depending on the HTTP method and the existence of a request body,",
							"    // extract the query parameters from the URL or the body into params_array",
							"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
							"        for (var parameter1 in requestBody) {",
							"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart+1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"     ",
							"    params_array.sort();                    //lexicographically sort parameters by key",
							"    var encoded_params = \"\";               ",
							"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
							"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
							"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
							"    }",
							"     ",
							"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\",timestamp);",
							" ",
							"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
							"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
							"    // console.log(requestData);",
							" ",
							"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
							"    var CryptoJS = require('crypto-js');",
							"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
							"     ",
							"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
							"    var prebase = IKEY+\":\"+ hmacDigest;",
							"    // console.log(\"prebase:\", prebase)",
							"     ",
							"    //encodes a string in base-64",
							"    var btoa = require('btoa');",
							"    var baseComplete = btoa(prebase);",
							"",
							"    var authHeader = \"Basic \"+ baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"function urlEncodeParams(value, index, array) {",
							"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
							"}",
							"",
							"// Get Accounts",
							"// Performing this request to pull the list of child accounts",
							"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
							"",
							"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
							"",
							"    pm.sendRequest({",
							"    url: url1,",
							"    method: \"POST\",",
							"    header: {",
							"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"        \"Date\": pm.globals.get(\"timestampHeader\")",
							"    },",
							"    body: {}",
							"    }, function(err, res) {",
							"    if (err) {",
							"        console.log(\"Error:\", err);",
							"        return;",
							"    }",
							"",
							"    // console.log(\"Response Status Code:\", res.code);",
							"    // console.log(\"Raw Response Body:\", res.text());",
							"",
							"    try {",
							"        var responseJson = JSON.parse(res.text());",
							"        if (responseJson.stat === \"OK\") {",
							"            // Initialize an object to store the mapping",
							"            var duoChildAccounts = {};",
							"",
							"            for (var i = 0; i < responseJson.response.length; i++) {",
							"                var accountId = responseJson.response[i].account_id;",
							"                var accountName = responseJson.response[i].name;",
							"                var apiHostname = responseJson.response[i].api_hostname;",
							"",
							"                // Store the account ID, name, and API hostname mapping in duoChildAccounts",
							"                duoChildAccounts[accountId] = {",
							"                    name: accountName,",
							"                    apiHostname: apiHostname",
							"                };",
							"            }",
							"",
							"            // Save the mapping object as a global variable",
							"            pm.globals.set(\"duoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"        } else {",
							"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
							"        }",
							"    } catch (error) {",
							"        console.log(\"Error parsing JSON:\", error);",
							"    }",
							"});",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Shared MSP Users",
			"item": [
				{
					"name": "Onboarding",
					"item": [
						{
							"name": "Create MSP Users",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Variable Declaration",
											"var DuoChildAccounts = JSON.parse(pm.collectionVariables.get(\"duoChildAccounts\"));",
											"var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
											"// console.log(\"Child Account Name:\", childAccountName);",
											"// console.log(\"Duo Child Accounts:\", DuoChildAccounts);",
											"",
											"",
											"// Get HMAC authentication header",
											"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
											"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
											"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
											"    var AUTH_TYPE = 'HMAC-SHA1';",
											"",
											"    if (requestUrl.indexOf(\"?\") == -1) {",
											"        requestUrl += \"?\";",
											"    }",
											"",
											"    var paramsStart = requestUrl.indexOf(\"?\");",
											"    var hostname_length = apiHostname.length + 8;",
											"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
											"",
											"    var params_unsorted = \"\";",
											"    var params_array = [];",
											"",
											"    if (Object.keys(requestBody).length !== 0) {",
											"        for (var parameter1 in requestBody) {",
											"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
											"            params_array.push(params_unsorted);",
											"        }",
											"    } else {",
											"        params_unsorted = requestUrl.substring(paramsStart + 1);",
											"        params_array = params_unsorted.split(\"&\");",
											"    }",
											"",
											"    params_array.sort();",
											"    var encoded_params = \"\";",
											"    if (params_array[0] !== \"\") {",
											"        var encoded_params_array = params_array.map(urlEncodeParams);",
											"        encoded_params = encoded_params_array.join(\"&\");",
											"    }",
											"",
											"    var moment = require('moment');",
											"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
											"    pm.globals.set(\"timestampHeader\", timestamp);",
											"",
											"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
											"    var CryptoJS = require('crypto-js');",
											"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
											"    var prebase = IKEY + \":\" + hmacDigest;",
											"    var btoa = require('btoa');",
											"    var baseComplete = btoa(prebase);",
											"    var authHeader = \"Basic \" + baseComplete;",
											"    return authHeader;",
											"}",
											"",
											"function urlEncodeParams(value, index, array) {",
											"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
											"}",
											"",
											"function processSingleAccount(DuoChildAccounts, accountId) {    ",
											"    var accountDetails = DuoChildAccounts[accountId];",
											"    var apiHostname = accountDetails.apiHostname;",
											"",
											"    // Store accountId temporarily for later use",
											"    pm.variables.set(\"temp_account_id\", accountId);",
											"",
											"    // Extract JSON data from Postman request body",
											"    var requestBody = pm.request.body;",
											"    var usersData = JSON.parse(requestBody);",
											"",
											"    // Construct URL with extracted data",
											"    var urlWithAccountId = `https://${apiHostname}/admin/v1/users/bulk_create?account_id=${accountId}&users=${JSON.stringify(usersData)}`;",
											"",
											"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", urlWithAccountId, {}, apiHostname));",
											"",
											"    pm.sendRequest({",
											"        url: urlWithAccountId,",
											"        method: \"POST\",",
											"        header: {",
											"            \"Content-Type\": \"application/x-www-form-urlencoded\",",
											"            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
											"            \"Date\": pm.globals.get(\"timestampHeader\")",
											"        },",
											"        body: {}",
											"    }, function(err, res) {",
											"        if (err) {",
											"            console.error(\"Error:\", err);",
											"            return;",
											"        }",
											"",
											"        try {",
											"            var responseJson = JSON.parse(res.text());",
											"            if (responseJson.stat === \"OK\") {",
											"                var sharedMspUsers = {};",
											"",
											"                // Extract relevant information",
											"                var jsonResponse = responseJson.response;",
											"",
											"                jsonResponse.forEach(function(user) {",
											"                    // Extract user information",
											"                    var username = user.username;",
											"                    var userId = user.user_id;",
											"",
											"                    // Check if account ID already exists in shared_msp_users",
											"                    if (!sharedMspUsers.hasOwnProperty(accountId)) {",
											"                        sharedMspUsers[accountId] = [];",
											"                    }",
											"",
											"                    // Check if user or user ID already exists for that account",
											"                    var userExists = sharedMspUsers[accountId].some(function(existingUser) {",
											"                        return existingUser.username === username || existingUser.userId === userId;",
											"                    });",
											"",
											"                    // Add user to shared_msp_users if not already present",
											"                    if (!userExists) {",
											"                        sharedMspUsers[accountId].push({",
											"                            \"username\": username,",
											"                            \"userId\": userId",
											"                        });",
											"                    }",
											"                });",
											"",
											"                // Set updated shared_msp_users collection variable",
											"                pm.collectionVariables.set(\"shared_msp_users\", JSON.stringify(sharedMspUsers));",
											"",
											"                // Display MSP users created successfully",
											"                var usersString = jsonResponse.map(user => user.username).join(\", \");",
											"                console.log(\"MSP users created successfully:\", usersString);",
											"            }",
											"        } catch (error) {",
											"            console.error(\"Error:\", error);",
											"        }",
											"    });",
											"}",
											"",
											"// Iterate over DuoChildAccounts to find matching account by name",
											"var matchingAccountId = null;",
											"for (var accountId in DuoChildAccounts) {",
											"    if (DuoChildAccounts.hasOwnProperty(accountId)) {",
											"        if (DuoChildAccounts[accountId].name === childAccountName) {",
											"            matchingAccountId = accountId;",
											"            break;",
											"        }",
											"    }",
											"}",
											"",
											"// Check if a matching account was found",
											"if (matchingAccountId !== null) {",
											"    // Process the account with the matching ID",
											"    processSingleAccount(DuoChildAccounts, matchingAccountId);",
											"} else {",
											"    console.error(\"Error: No account found with the specified name in DuoChildAccounts.\");",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "Date",
										"value": "{{timestampHeader}}"
									},
									{
										"key": "Authorization",
										"value": "{{hmacAuthHeader}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "[\n    {\n        \"username\": \"mspadmin01\",\n        \"realname\": \"MSP Admin01\",\n        \"email\": \"mspadmin01@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin01\"\n    },\n    {\n        \"username\": \"mspadmin02\",\n        \"realname\": \"MSP Admin02\",\n        \"email\": \"mspadmin02@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin02\"\n    },\n    {\n        \"username\": \"mspadmin03\",\n        \"realname\": \"MSP Admin03\",\n        \"email\": \"mspadmin03@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin03\"\n    },\n    {\n        \"username\": \"mspadmin04\",\n        \"realname\": \"MSP Admin04\",\n        \"email\": \"mspadmin04@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin04\"\n    },\n    {\n        \"username\": \"mspadmin05\",\n        \"realname\": \"MSP Admin05\",\n        \"email\": \"mspadmin05@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin05\"\n    },\n    {\n        \"username\": \"mspadmin06\",\n        \"realname\": \"MSP Admin06\",\n        \"email\": \"mspadmin06@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin06\"\n    },\n    {\n        \"username\": \"mspadmin07\",\n        \"realname\": \"MSP Admin07\",\n        \"email\": \"mspadmin07@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin07\"\n    },\n    {\n        \"username\": \"mspadmin08\",\n        \"realname\": \"MSP Admin08\",\n        \"email\": \"mspadmin08@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin08\"\n    },\n    {\n        \"username\": \"mspadmin09\",\n        \"realname\": \"MSP Admin09\",\n        \"email\": \"mspadmin09@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin09\"\n    },\n    {\n        \"username\": \"mspadmin10\",\n        \"realname\": \"MSP Admin10\",\n        \"email\": \"mspadmin10@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin10\"\n    }\n]\n"
								},
								"url": {
									"raw": "{{duo_url}}",
									"host": [
										"{{duo_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create MSP Phones",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Variable Declaration",
											"var DuoChildAccounts = JSON.parse(pm.collectionVariables.get(\"duoChildAccounts\"));",
											"    var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
											"    // console.log(\"Child Account Name:\", childAccountName);",
											"    // console.log(\"Duo Child Accounts:\", DuoChildAccounts);",
											"",
											"",
											"// Get HMAC authentication header",
											"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
											"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
											"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
											"    var AUTH_TYPE = 'HMAC-SHA1';",
											"",
											"    if (requestUrl.indexOf(\"?\") == -1) {",
											"        requestUrl += \"?\";",
											"    }",
											"",
											"    var paramsStart = requestUrl.indexOf(\"?\");",
											"    var hostname_length = apiHostname.length + 8;",
											"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
											"",
											"    var params_unsorted = \"\";",
											"    var params_array = [];",
											"",
											"    if (Object.keys(requestBody).length !== 0) {",
											"        for (var parameter1 in requestBody) {",
											"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
											"            params_array.push(params_unsorted);",
											"        }",
											"    } else {",
											"        params_unsorted = requestUrl.substring(paramsStart + 1);",
											"        params_array = params_unsorted.split(\"&\");",
											"    }",
											"",
											"    params_array.sort();",
											"    var encoded_params = \"\";",
											"    if (params_array[0] !== \"\") {",
											"        var encoded_params_array = params_array.map(urlEncodeParams);",
											"        encoded_params = encoded_params_array.join(\"&\");",
											"    }",
											"",
											"    var moment = require('moment');",
											"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
											"    pm.globals.set(\"timestampHeader\", timestamp);",
											"",
											"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
											"    var CryptoJS = require('crypto-js');",
											"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
											"    var prebase = IKEY + \":\" + hmacDigest;",
											"    var btoa = require('btoa');",
											"    var baseComplete = btoa(prebase);",
											"    var authHeader = \"Basic \" + baseComplete;",
											"    return authHeader;",
											"}",
											"",
											"function urlEncodeParams(value, index, array) {",
											"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
											"}",
											"",
											"// Process single account",
											"function processSingleAccount(DuoChildAccounts, accountId) {",
											"    var accountDetails = DuoChildAccounts[accountId];",
											"    var apiHostname = accountDetails.apiHostname;",
											"",
											"    // Store accountId temporarily for later use",
											"    pm.variables.set(\"temp_account_id\", accountId);",
											"",
											"    // Extract JSON data from Postman request body",
											"    var requestBody = pm.request.body;",
											"    var phonesData = JSON.parse(requestBody);",
											"",
											"    // Construct URL with extracted data",
											"    var urlWithAccountId = `https://${apiHostname}/admin/v1/phones?account_id=${accountId}`;",
											"",
											"    phonesData.forEach(function (phone, index) {",
											"        var phoneUrl = `${urlWithAccountId}&number=${phone.phone}&name=${phone.name}&platform=generic smartphone&type=mobile`;",
											"",
											"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", phoneUrl, {}, apiHostname));",
											"        ",
											"        pm.sendRequest({",
											"            url: phoneUrl,",
											"            method: \"POST\",",
											"            header: {",
											"                \"Content-Type\": \"application/x-www-form-urlencoded\",",
											"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
											"                \"Date\": pm.globals.get(\"timestampHeader\")",
											"            },",
											"            body: {}",
											"        },  function(err, res) {",
											"            if (err) {",
											"                console.error(\"Error:\", err);",
											"                return;",
											"            }",
											"",
											"            try {",
											"                var responseJson = JSON.parse(res.text());",
											"                // console.log(\"Response JSON:\", responseJson); // Log the response JSON",
											"                if (responseJson.stat === \"OK\") {",
											"                    var jsonResponse = responseJson.response;",
											"                    var phoneId = jsonResponse.phone_id;",
											"                    var phoneNumber = jsonResponse.number;",
											"                    var phoneName = jsonResponse.name;",
											"                    ",
											"                    // Retrieve current msp_phone_numbers collection or initialize as an array",
											"                    var mspPhoneNumbers = pm.collectionVariables.get(\"msp_phone_numbers\");",
											"                    // console.log(\"Current msp_phone_numbers:\", JSON.stringify(mspPhoneNumbers));",
											"",
											"                    // Parse msp_phone_numbers if it exists",
											"                    if (mspPhoneNumbers) {",
											"                        try {",
											"                            mspPhoneNumbers = JSON.parse(mspPhoneNumbers);",
											"                        } catch (error) {",
											"                            // If parsing fails, set mspPhoneNumbers to an empty array",
											"                            mspPhoneNumbers = [];",
											"                        }",
											"                    } else {",
											"                        // If msp_phone_numbers doesn't exist, set it to an empty array",
											"                        mspPhoneNumbers = [];",
											"                    }",
											"",
											"                    // Add phone details to the collection",
											"                    mspPhoneNumbers.push({phone_id: phoneId, number: phoneNumber, name: phoneName});",
											"",
											"                    // console.log(\"Updated msp_phone_numbers:\", JSON.stringify(mspPhoneNumbers)); // Log the updated collection",
											"",
											"                    // Update msp_phone_numbers collection variable",
											"                    var mspPhoneNumbersString = JSON.stringify(mspPhoneNumbers);",
											"                    pm.collectionVariables.set(\"msp_phone_numbers\", mspPhoneNumbersString);",
											"                    ",
											"                    // console.log(\"Phone created successfully:\", phone);",
											"",
											"                    // Check if this is the last phone being processed",
											"                    if (index === phonesData.length - 1) {",
											"                        sendSMSActivationCode(accountId);",
											"                    }",
											"                } else {",
											"                    console.error(\"Error creating phone:\", responseJson.message);",
											"                }",
											"            } catch (error) {",
											"                console.error(\"Error:\", error);",
											"            }",
											"        });",
											"    });",
											"}",
											"",
											"// Send SMS Activation Code for each phone",
											"function sendSMSActivationCode(accountId) {",
											"    var mspPhoneNumbers = JSON.parse(pm.collectionVariables.get(\"msp_phone_numbers\"));",
											"    var apiHostname = DuoChildAccounts[accountId].apiHostname;",
											"",
											"    mspPhoneNumbers.forEach(function (phoneDetails, index) {",
											"        var phoneId = phoneDetails.phone_id;",
											"        var smsActivationUrl = `https://${apiHostname}/admin/v1/phones/${phoneId}/send_sms_activation?account_id=${accountId}&install=1`;",
											"",
											"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", smsActivationUrl, {}, apiHostname));",
											"",
											"        pm.sendRequest({",
											"            url: smsActivationUrl,",
											"            method: \"POST\",",
											"            header: {",
											"                \"Content-Type\": \"application/x-www-form-urlencoded\",",
											"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
											"                \"Date\": pm.globals.get(\"timestampHeader\")",
											"            },",
											"            body: {}",
											"        }, function(err, res) {",
											"            if (err) {",
											"                console.error(\"Error sending SMS activation code for phone ID:\", phoneId, err);",
											"                return;",
											"            }",
											"",
											"            try {",
											"                var responseJson = JSON.parse(res.text());",
											"                // console.log(\"Response JSON for phone ID:\", phoneId, \":\", responseJson); // Log the response JSON",
											"                if (responseJson.stat === \"OK\") {",
											"                    console.log(`${phoneDetails.name}'s phone was added successfully and a Duo Mobile activation code has been sent to ${phoneDetails.number}`);",
											"                }",
											"            } catch (error) {",
											"                console.error(\"Error parsing response for phone ID:\", phoneId, \":\", error);",
											"            }",
											"        });",
											"    });",
											"}",
											"",
											"// Iterate over DuoChildAccounts to find matching account by name",
											"var matchingAccountId = null;",
											"",
											"    for (var accountId in DuoChildAccounts) {",
											"        if (DuoChildAccounts.hasOwnProperty(accountId)) {",
											"            var accountDetails = DuoChildAccounts[accountId];",
											"            if (accountDetails.name === childAccountName) {",
											"                matchingAccountId = accountId;",
											"                break;",
											"            }",
											"        }",
											"    }",
											"",
											"    // Check if a matching account was found",
											"    if (matchingAccountId !== null) {",
											"        // Process the account with the matching ID",
											"        processSingleAccount(DuoChildAccounts, matchingAccountId);",
											"    } else {",
											"        console.error(\"Error: No account found with the specified name in DuoChildAccounts.\");",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "Date",
										"value": "{{timestampHeader}}"
									},
									{
										"key": "Authorization",
										"value": "{{hmacAuthHeader}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "[\n    {\n        \"name\": \"John Smith\",\n        \"phone\": \"3137123456\"\n    },\n    {\n        \"name\": \"Emily Johnson\",\n        \"phone\": \"3138234567\"\n    },\n    {\n        \"name\": \"Michael Williams\",\n        \"phone\": \"3139345678\"\n    },\n    {\n        \"name\": \"Sarah Davis\",\n        \"phone\": \"3135456789\"\n    },\n    {\n        \"name\": \"David Brown\",\n        \"phone\": \"3132547890\"\n    },\n    {\n        \"name\": \"Jennifer Martinez\",\n        \"phone\": \"3132678901\"\n    },\n    {\n        \"name\": \"Robert Wilson\",\n        \"phone\": \"3133789012\"\n    },\n    {\n        \"name\": \"Amanda Anderson\",\n        \"phone\": \"3134890123\"\n    },\n    {\n        \"name\": \"William Taylor\",\n        \"phone\": \"3135901234\"\n    },\n    {\n        \"name\": \"Laura Garcia\",\n        \"phone\": \"3136012345\"\n    }\n]\n"
								},
								"url": {
									"raw": "{{duo_url}}",
									"host": [
										"{{duo_url}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Attach MSP Phones to MSP Users",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Variable Declaration",
											"var DuoChildAccounts = JSON.parse(pm.collectionVariables.get(\"duoChildAccounts\"));",
											"var sharedMspUsers = JSON.parse(pm.collectionVariables.get(\"shared_msp_users\"));",
											"var mspPhoneNumbers = JSON.parse(pm.collectionVariables.get(\"msp_phone_numbers\"));",
											"var childAccountName = pm.collectionVariables.get(\"child_account_name\");",
											"",
											"// Get HMAC authentication header",
											"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {",
											"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY",
											"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY",
											"",
											"    if (requestUrl.indexOf(\"?\") == -1) {",
											"        requestUrl += \"?\";",
											"    }",
											"",
											"    var paramsStart = requestUrl.indexOf(\"?\");",
											"    var hostname_length = apiHostname.length + 8;",
											"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
											"",
											"    var params_unsorted = \"\";",
											"    var params_array = [];",
											"",
											"    if (Object.keys(requestBody).length !== 0) {",
											"        for (var parameter1 in requestBody) {",
											"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
											"            params_array.push(params_unsorted);",
											"        }",
											"    } else {",
											"        params_unsorted = requestUrl.substring(paramsStart + 1);",
											"        params_array = params_unsorted.split(\"&\");",
											"    }",
											"",
											"    params_array.sort();",
											"    var encoded_params = \"\";",
											"    if (params_array[0] !== \"\") {",
											"        var encoded_params_array = params_array.map(urlEncodeParams);",
											"        encoded_params = encoded_params_array.join(\"&\");",
											"    }",
											"",
											"    var moment = require('moment');",
											"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
											"    pm.globals.set(\"timestampHeader\", timestamp);",
											"",
											"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;",
											"    var CryptoJS = require('crypto-js');",
											"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
											"    var prebase = IKEY + \":\" + hmacDigest;",
											"    var btoa = require('btoa');",
											"    var baseComplete = btoa(prebase);",
											"    var authHeader = \"Basic \" + baseComplete;",
											"    return authHeader;",
											"}",
											"",
											"function urlEncodeParams(value, index, array) {",
											"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
											"}",
											"",
											"// Process single account",
											"function processSingleAccount(DuoChildAccounts, accountId) {",
											"    var accountDetails = DuoChildAccounts[accountId];",
											"    var apiHostname = accountDetails.apiHostname;",
											"",
											"    // Iterate over each user ID in shared_msp_users",
											"    for (var accountId in sharedMspUsers) {",
											"        if (sharedMspUsers.hasOwnProperty(accountId)) {",
											"            var userDetails = sharedMspUsers[accountId];",
											"            userDetails.forEach(function(userDetail) {",
											"                var userId = userDetail.userId;",
											"",
											"                // Iterate over each phone ID in msp_phone_numbers",
											"                mspPhoneNumbers.forEach(function(phoneDetails) {",
											"                    var phoneId = phoneDetails.phone_id;",
											"",
											"                    // Construct the URL to add the phone ID to the user ID",
											"                    var Url = `https://${apiHostname}/admin/v1/users/${userId}/phones?phone_id=${phoneId}&account_id=${accountId}`;",
											"",
											"                    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", Url, {}, apiHostname));",
											"",
											"                    pm.sendRequest({",
											"                        url: Url,",
											"                        method: \"POST\",",
											"                        header: {",
											"                            \"Content-Type\": \"application/x-www-form-urlencoded\",",
											"                            \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
											"                            \"Date\": pm.globals.get(\"timestampHeader\")",
											"                        },",
											"                        body: {}",
											"                    }, function(err, res) {",
											"                        if (err) {",
											"                            console.error(\"Error adding phone ID to user ID:\", userId, \":\", err);",
											"                            return;",
											"                        }",
											"",
											"                        try {",
											"                            var responseJson = JSON.parse(res.text());",
											"                            if (responseJson.stat === \"OK\") {",
											"                                console.log(`${phoneDetails.name}'s phone (${phoneDetails.number}) was added successfully to ${userDetail.username}`);",
											"                            } else {",
											"                                console.error(\"Error adding phone ID to user ID:\", userId, \":\", responseJson);",
											"                            }",
											"                        } catch (error) {",
											"                            console.error(\"Error parsing response for user ID:\", userId, \":\", error);",
											"                        }",
											"                    });",
											"                });",
											"            });",
											"        }",
											"    }",
											"}",
											"",
											"",
											"// Iterate over DuoChildAccounts to find matching account by name",
											"var matchingAccountId = null;",
											"for (var accountId in DuoChildAccounts) {",
											"    if (DuoChildAccounts.hasOwnProperty(accountId)) {",
											"        if (DuoChildAccounts[accountId].name === childAccountName) {",
											"            matchingAccountId = accountId;",
											"            break;",
											"        }",
											"    }",
											"}",
											"",
											"// Check if a matching account was found",
											"if (matchingAccountId !== null) {",
											"    // Process the account with the matching ID",
											"    processSingleAccount(DuoChildAccounts, matchingAccountId);",
											"} else {",
											"    console.error(\"Error: No account found with the specified name in DuoChildAccounts.\");",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "Date",
										"value": "{{timestampHeader}}"
									},
									{
										"key": "Authorization",
										"value": "{{hmacAuthHeader}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "[\n    {\n        \"username\": \"mspadmin01\",\n        \"realname\": \"MSP Admin01\",\n        \"email\": \"mspadmin01@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin01\"\n    },\n    {\n        \"username\": \"mspadmin02\",\n        \"realname\": \"MSP Admin02\",\n        \"email\": \"mspadmin02@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin02\"\n    },\n    {\n        \"username\": \"mspadmin03\",\n        \"realname\": \"MSP Admin03\",\n        \"email\": \"mspadmin03@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin03\"\n    },\n    {\n        \"username\": \"mspadmin04\",\n        \"realname\": \"MSP Admin04\",\n        \"email\": \"mspadmin04@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin04\"\n    },\n    {\n        \"username\": \"mspadmin05\",\n        \"realname\": \"MSP Admin05\",\n        \"email\": \"mspadmin05@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin05\"\n    },\n    {\n        \"username\": \"mspadmin06\",\n        \"realname\": \"MSP Admin06\",\n        \"email\": \"mspadmin06@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin06\"\n    },\n    {\n        \"username\": \"mspadmin07\",\n        \"realname\": \"MSP Admin07\",\n        \"email\": \"mspadmin07@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin07\"\n    },\n    {\n        \"username\": \"mspadmin08\",\n        \"realname\": \"MSP Admin08\",\n        \"email\": \"mspadmin08@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin08\"\n    },\n    {\n        \"username\": \"mspadmin09\",\n        \"realname\": \"MSP Admin09\",\n        \"email\": \"mspadmin09@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin09\"\n    },\n    {\n        \"username\": \"mspadmin10\",\n        \"realname\": \"MSP Admin10\",\n        \"email\": \"mspadmin10@example.com\",\n        \"status\": \"active\",\n        \"notes\": \"N/A\",\n        \"firstname\": \"MSP\",\n        \"lastname\": \"Admin10\"\n    }\n]\n"
								},
								"url": {
									"raw": "{{duo_url}}",
									"host": [
										"{{duo_url}}"
									]
								}
							},
							"response": []
						}
					],
					"description": "This set of requests facilitates the creation of shared MSP users for accessing customer resources, adds techs' phone numbers to the account, sends them Duo Mobile activation links for installation and activation, and assigns each tech's phone number to each shared Duo user account.\n\n1. **Create MSP Users:**\n    \n    - This request creates a list of MSP users designated in JSON format within the request body.\n        \n        - Update the JSON body with your list of MSP (admin) users.\n            \n2. **Create MSP Phones:**\n    \n    - Imports a list of individual phone numbers belonging to each tech.\n        \n    - Sends each tech a unique activation code for Duo Mobile installation and activation.\n        \n    - Stores the phone IDs mapped to the corresponding phone numbers and names.\n        \n        - Update the JSON body with your list of phone numbers.\n            \n3. **Attach MSP Phones to MSP Users:**\n    \n    - Utilizes the `msp_phone_numbers` to sequentially assign phone numbers to the list of MSP shared user accounts.\n        \n\n_Note:_ There might be an issue with iterating over the full list of `phone_ids` for sending Duo Mobile activation links and assigning each number to every MSP user account. If any failures occur during execution, repeat sending the requests."
				},
				{
					"name": "Offboarding",
					"item": [
						{
							"name": "Phone Report",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Variable Declaration\r",
											"var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
											"\r",
											"// Get HMAC authentication header\r",
											"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
											"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
											"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
											"    var AUTH_TYPE = 'HMAC-SHA1';\r",
											"\r",
											"    if (requestUrl.indexOf(\"?\") == -1) {\r",
											"        requestUrl += \"?\";\r",
											"    }\r",
											"\r",
											"    var paramsStart = requestUrl.indexOf(\"?\");\r",
											"    var hostname_length = apiHostname.length + 8;\r",
											"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
											"\r",
											"    var params_unsorted = \"\";\r",
											"    var params_array = [];\r",
											"\r",
											"    if (Object.keys(requestBody).length !== 0) {\r",
											"        for (var parameter1 in requestBody) {\r",
											"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
											"            params_array.push(params_unsorted);\r",
											"        }\r",
											"    } else {\r",
											"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
											"        params_array = params_unsorted.split(\"&\");\r",
											"    }\r",
											"\r",
											"    params_array.sort();\r",
											"    var encoded_params = \"\";\r",
											"    if (params_array[0] !== \"\") {\r",
											"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
											"        encoded_params = encoded_params_array.join(\"&\");\r",
											"    }\r",
											"\r",
											"    var moment = require('moment');\r",
											"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
											"    pm.globals.set(\"timestampHeader\", timestamp);\r",
											"\r",
											"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
											"    var CryptoJS = require('crypto-js');\r",
											"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
											"    var prebase = IKEY + \":\" + hmacDigest;\r",
											"    var btoa = require('btoa');\r",
											"    var baseComplete = btoa(prebase);\r",
											"    var authHeader = \"Basic \" + baseComplete;\r",
											"    return authHeader;\r",
											"}\r",
											"\r",
											"function urlEncodeParams(value, index, array) {\r",
											"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
											"}\r",
											"\r",
											"var keys = Object.keys(DuoChildAccounts);\r",
											"var phone_id_search = pm.collectionVariables.get(\"phone_id_search\");  // Initialize phone_id_search at a higher scope\r",
											"var foundAccounts = [];  // Initialize foundAccounts array to track accounts where the phone number is found\r",
											"\r",
											"pm.collectionVariables.set(\"phone_id_list\", []); // Clear the phone_id_list\r",
											"processAccount(keys, 0);\r",
											"\r",
											"\r",
											"function processAccount(keys, index) {\r",
											"    if (index >= keys.length) {\r",
											"        // All accounts have been processed\r",
											"        // console.log(\"Completed processing all accounts.\");\r",
											"        if (foundAccounts.length > 0) {\r",
											"            console.log(`Phone number ${phone_id_search} was found on the following accounts:`);\r",
											"            foundAccounts.forEach(acc => {\r",
											"                console.log(`Account Name: ${acc.name}, Account ID: ${acc.id}`);\r",
											"            });\r",
											"        } else {\r",
											"            console.log(`Phone number ${phone_id_search} was not found in any accounts.`);\r",
											"        }\r",
											"        return;\r",
											"    }\r",
											"\r",
											"    let accountId = keys[index];\r",
											"    if (accountId && accountId.trim() !== \"\") {\r",
											"        var accountDetails = DuoChildAccounts[accountId];\r",
											"        var accountName = accountDetails.name;\r",
											"        var apiHostname = accountDetails.apiHostname; // Get the apiHostname for the current account\r",
											"\r",
											"        // Update the URL to use the specific apiHostname\r",
											"        var urlWithAccountId = `https://${apiHostname}/admin/v1/users?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;\r",
											"\r",
											"        // Generate the HMAC header using the specific apiHostname\r",
											"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname));\r",
											"\r",
											"        pm.sendRequest({\r",
											"            url: urlWithAccountId,\r",
											"            method: \"GET\",\r",
											"            header: {\r",
											"                \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
											"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
											"                \"Date\": pm.globals.get(\"timestampHeader\")\r",
											"            }\r",
											"        }, function(err, res) {\r",
											"            if (res.code === 200) {\r",
											"                var resJson = res.json();\r",
											"                var users = resJson.response || [];\r",
											"                var phone_id_list = pm.collectionVariables.get(\"phone_id_list\") || [];\r",
											"\r",
											"                // Search for the phone number and collect phone IDs\r",
											"                users.forEach(user => {\r",
											"                    user.phones.forEach(phone => {\r",
											"                        if (phone.number === phone_id_search) {\r",
											"                            phone_id_list.push(phone.phone_id);\r",
											"                            if (!foundAccounts.some(acc => acc.id === accountId)) {\r",
											"                                foundAccounts.push({ id: accountId, name: accountName });\r",
											"                            }\r",
											"                        }\r",
											"                    });\r",
											"                });\r",
											"\r",
											"                // Update the global variable with the new list of phone IDs\r",
											"                pm.collectionVariables.set(\"phone_id_list\", phone_id_list);\r",
											"\r",
											"                if (resJson.metadata && resJson.metadata.next_offset) {\r",
											"                    pm.globals.set('next_offset', resJson.metadata.next_offset);\r",
											"                    processAccount(keys, index);\r",
											"                } else {\r",
											"                    pm.globals.set('next_offset', 0);\r",
											"                    processAccount(keys, index + 1);\r",
											"                }\r",
											"            } else {\r",
											"                console.error('Request failed for account:', accountName, '; Error:', err, '; Response:', res);\r",
											"                // Move to the next account in case of an error\r",
											"                processAccount(keys, index + 1);\r",
											"            }\r",
											"        });\r",
											"    }\r",
											"}\r",
											"\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.globals.unset(\"timestampHeader\");",
											"    pm.globals.unset(\"hmacAuthHeader\");",
											"    pm.globals.unset(\"accountId\");",
											"    pm.globals.unset(\"next_offset\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									},
									{
										"key": "Date",
										"value": "{{timestampHeader}}"
									},
									{
										"key": "Authorization",
										"value": "{{hmacAuthHeader}}"
									}
								],
								"url": {
									"raw": "{{duo_url}}",
									"host": [
										"{{duo_url}}"
									],
									"query": [
										{
											"key": "",
											"value": "",
											"disabled": true
										}
									]
								},
								"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
							},
							"response": []
						},
						{
							"name": "Delete Phone",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Variable Declaration\r",
											"var DuoChildAccounts = JSON.parse(pm.globals.get(\"duoChildAccounts\"));\r",
											"\r",
											"// Get HMAC authentication header\r",
											"function getAuthHeader(httpMethod, requestUrl, requestBody, apiHostname) {\r",
											"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); // Accounts API IKEY\r",
											"    var SKEY = pm.globals.get(\"accounts_api_skey\"); // Accounts API SKEY\r",
											"    var AUTH_TYPE = 'HMAC-SHA1';\r",
											"\r",
											"    if (requestUrl.indexOf(\"?\") == -1) {\r",
											"        requestUrl += \"?\";\r",
											"    }\r",
											"\r",
											"    var paramsStart = requestUrl.indexOf(\"?\");\r",
											"    var hostname_length = apiHostname.length + 8;\r",
											"    var api_call = requestUrl.slice(hostname_length, paramsStart);\r",
											"\r",
											"    var params_unsorted = \"\";\r",
											"    var params_array = [];\r",
											"\r",
											"    if (Object.keys(requestBody).length !== 0) {\r",
											"        for (var parameter1 in requestBody) {\r",
											"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];\r",
											"            params_array.push(params_unsorted);\r",
											"        }\r",
											"    } else {\r",
											"        params_unsorted = requestUrl.substring(paramsStart + 1);\r",
											"        params_array = params_unsorted.split(\"&\");\r",
											"    }\r",
											"\r",
											"    params_array.sort();\r",
											"    var encoded_params = \"\";\r",
											"    if (params_array[0] !== \"\") {\r",
											"        var encoded_params_array = params_array.map(urlEncodeParams);\r",
											"        encoded_params = encoded_params_array.join(\"&\");\r",
											"    }\r",
											"\r",
											"    var moment = require('moment');\r",
											"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");\r",
											"    pm.globals.set(\"timestampHeader\", timestamp);\r",
											"\r",
											"    var requestData = timestamp + \"\\n\" + httpMethod + \"\\n\" + apiHostname + \"\\n\" + api_call + \"\\n\" + encoded_params;\r",
											"    var CryptoJS = require('crypto-js');\r",
											"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);\r",
											"    var prebase = IKEY + \":\" + hmacDigest;\r",
											"    var btoa = require('btoa');\r",
											"    var baseComplete = btoa(prebase);\r",
											"    var authHeader = \"Basic \" + baseComplete;\r",
											"    return authHeader;\r",
											"}\r",
											"\r",
											"function urlEncodeParams(value, index, array) {\r",
											"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);\r",
											"}\r",
											"\r",
											"var keys = Object.keys(DuoChildAccounts);\r",
											"pm.collectionVariables.set(\"phone_id_list\", []); // Clear the phone_id_list\r",
											"processAccount(keys, 0);\r",
											"\r",
											"async function processAccount(keys, index) {\r",
											"    if (index >= keys.length) {\r",
											"        // All accounts have been processed\r",
											"        return;\r",
											"    }\r",
											"\r",
											"    let accountId = keys[index];\r",
											"    let accountDetails = DuoChildAccounts[accountId];\r",
											"    let apiHostname = accountDetails.apiHostname;\r",
											"\r",
											"    // First, retrieve the phone IDs to add to the phone_id_list\r",
											"    await fetchPhoneIds(accountId, accountDetails, apiHostname);\r",
											"\r",
											"    // Then, delete each phone ID in phone_id_list\r",
											"    await deletePhoneIds(accountId, accountDetails, apiHostname);\r",
											"\r",
											"    // Move to the next account\r",
											"    processAccount(keys, index + 1);\r",
											"}\r",
											"\r",
											"async function fetchPhoneIds(accountId, accountDetails, apiHostname) {\r",
											"    var urlWithAccountId = `https://${apiHostname}/admin/v1/users?account_id=${accountId}&offset=${pm.globals.get(\"next_offset\") || 0}`;\r",
											"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"GET\", urlWithAccountId, {}, apiHostname));\r",
											"\r",
											"    return new Promise((resolve, reject) => {\r",
											"        pm.sendRequest({\r",
											"            url: urlWithAccountId,\r",
											"            method: \"GET\",\r",
											"            header: {\r",
											"                \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
											"                \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
											"                \"Date\": pm.globals.get(\"timestampHeader\")\r",
											"            }\r",
											"        }, function(err, res) {\r",
											"            if (res.code === 200) {\r",
											"                var resJson = res.json();\r",
											"                var users = resJson.response || [];\r",
											"                var phone_id_search = pm.collectionVariables.get(\"phone_id_search\"); \r",
											"                var phone_id_list = pm.collectionVariables.get(\"phone_id_list\") || [];\r",
											"\r",
											"                users.forEach(user => {\r",
											"                    user.phones.forEach(phone => {\r",
											"                        if (phone.number === phone_id_search) {\r",
											"                            phone_id_list.push(phone.phone_id);\r",
											"                        }\r",
											"                    });\r",
											"                });\r",
											"\r",
											"                pm.collectionVariables.set(\"phone_id_list\", phone_id_list);\r",
											"\r",
											"                if (resJson.metadata && resJson.metadata.next_offset) {\r",
											"                    pm.globals.set('next_offset', resJson.metadata.next_offset);\r",
											"                    resolve(fetchPhoneIds(accountId, accountDetails, apiHostname));  // Recursive call if more users are present\r",
											"                } else {\r",
											"                    pm.globals.set('next_offset', 0);\r",
											"                    resolve();\r",
											"                }\r",
											"            } else {\r",
											"                console.error('Request failed for account:', accountDetails.name, '; Error:', err, '; Response:', res);\r",
											"                resolve();  // Resolve even in case of error to proceed with next steps\r",
											"            }\r",
											"        });\r",
											"    });\r",
											"}\r",
											"\r",
											"async function deletePhoneIds(accountId, accountDetails, apiHostname) {\r",
											"    var phone_id_list = pm.collectionVariables.get(\"phone_id_list\") || [];\r",
											"\r",
											"    for (let phone_id of phone_id_list) {\r",
											"        var urlWithPhoneId = `https://${apiHostname}/admin/v1/phones/${phone_id}?account_id=${accountId}`;\r",
											"        pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"DELETE\", urlWithPhoneId, {}, apiHostname));\r",
											"\r",
											"        await new Promise((resolve, reject) => {\r",
											"            pm.sendRequest({\r",
											"                url: urlWithPhoneId,\r",
											"                method: \"DELETE\",\r",
											"                header: {\r",
											"                    \"Content-Type\": \"application/x-www-form-urlencoded\",\r",
											"                    \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),\r",
											"                    \"Date\": pm.globals.get(\"timestampHeader\")\r",
											"                }\r",
											"            }, function(err, res) {\r",
											"                if (err || res.code !== 200 || res.json().stat !== \"OK\") {\r",
											"                    console.error('Failed to delete phone ID:', phone_id, '; Account:', accountDetails.name, '; Error:', err, '; Response:', res);\r",
											"                    resolve(); // Resolve to continue with next phone ID\r",
											"                } else {\r",
											"                    console.log('Successfully deleted phone ID:', phone_id, 'for account:', accountDetails.name);\r",
											"                    resolve(); // Resolve to continue with next phone ID\r",
											"                }\r",
											"            });\r",
											"        });\r",
											"    }\r",
											"}\r",
											"\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.globals.unset(\"timestampHeader\");",
											"    pm.globals.unset(\"hmacAuthHeader\");",
											"    pm.globals.unset(\"accountId\");",
											"    pm.globals.unset(\"next_offset\");"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/x-www-form-urlencoded"
									},
									{
										"key": "Date",
										"value": "{{timestampHeader}}"
									},
									{
										"key": "Authorization",
										"value": "{{hmacAuthHeader}}"
									}
								],
								"url": {
									"raw": "{{duo_url}}",
									"host": [
										"{{duo_url}}"
									],
									"query": [
										{
											"key": "",
											"value": "",
											"disabled": true
										}
									]
								},
								"description": "Returns a paged list of users. To fetch all results, call repeatedly with theÂ `offset`Â parameter as long as the result metadata has aÂ `next_offset`Â value. IfÂ `username`Â is not provided, the list will contain all users. IfÂ `username`Â is provided, the list will either contain a single user (if a match was found) or no users. Requires \"Grant read resource\" API permission."
							},
							"response": []
						}
					],
					"description": "These reqeusts enable you to search for and remove a particular phone number from each user account across all child accounts.\n\n1. **Phone Report:**\n    - This request checks for the specified `phone_id_search` across all child accounts.\n    - It stores a list of phone IDs associated with the searched phone number.\n2. **Delete Phone:**\n    - Removes the specified phone number from every user on each Duo child account.",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									"//Generate the authorization header",
									"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
									"    // Ensure requestUrl is a string",
									"    requestUrl = String(requestUrl);",
									"",
									"    // Retrieve Accounts API IKEY, SKEY and API Hostname",
									"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); ",
									"    var SKEY = pm.globals.get(\"accounts_api_skey\"); ",
									"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); ",
									"",
									"    // Check if API_HOSTNAME is defined",
									"    if (!API_HOSTNAME) {",
									"        throw new Error(\"API_HOSTNAME is not defined\");",
									"    }",
									"",
									"    // Add a '?' to the end of the URL if it doesn't exist",
									"    if (requestUrl.indexOf(\"?\") === -1) {",
									"        requestUrl += \"?\";",
									"    }",
									"",
									"    // Calculate the starting point of the query parameters in the URL",
									"    var paramsStart = requestUrl.indexOf(\"?\");",
									"",
									"    // Calculate the length of the hostname",
									"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
									"",
									"    // Extract the Duo API endpoint",
									"    var api_call = requestUrl.slice(hostname_length, paramsStart);",
									"    api_call = api_call.replace(\"}}\", \"\");",
									"",
									"    var params_unsorted = \"\";",
									"    var params_array = [];",
									"",
									"    // Depending on the HTTP method, extract parameters from URL or body",
									"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
									"        for (var parameter1 in requestBody) {",
									"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
									"            params_array.push(params_unsorted);",
									"        }",
									"    } else {",
									"        params_unsorted = requestUrl.substring(paramsStart+1);",
									"        params_array = params_unsorted.split(\"&\");",
									"    }",
									"",
									"    // Sort parameters lexicographically by key",
									"    params_array.sort();                    ",
									"    var encoded_params = \"\";",
									"",
									"    // If there are parameters, encode and join them",
									"    if (params_array[0] !== \"\"){",
									"        var encoded_params_array = params_array.map(urlEncodeParams);  ",
									"        encoded_params = encoded_params_array.join(\"&\");",
									"    }",
									"",
									"    // Get the current timestamp in the RFC 2822 format",
									"    var moment = require('moment');",
									"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
									"    pm.globals.set(\"timestampHeader\",timestamp);",
									" ",
									"    // Construct the string to be signed",
									"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
									" ",
									"    // Compute the HMAC-SHA1 signature",
									"    var CryptoJS = require('crypto-js');",
									"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
									"     ",
									"    // Construct the Auth header",
									"    var btoa = require('btoa');",
									"    var prebase = IKEY+\":\"+ hmacDigest;",
									"    var baseComplete = btoa(prebase);",
									"    var authHeader = \"Basic \"+ baseComplete;",
									"",
									"    return authHeader;",
									"}",
									"",
									"// URL encode parameters",
									"function urlEncodeParams(value, index, array) {",
									"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
									"}",
									"",
									"// Set the authorization header",
									"pm.globals.set(\"hmacAuthHeader\", getAuthHeader(pm.request.method, pm.request.url, pm.request.body));",
									"",
									"// Add the request headers",
									"pm.request.headers.add({key: 'Date', value: \"{{timestampHeader}}\" });",
									"pm.request.headers.add({key: 'Authorization', value: \"{{hmacAuthHeader}}\" });",
									"pm.request.headers.add({key: 'Content-Type', value: 'application/x-www-form-urlencoded' });"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"packages": {},
								"exec": [
									""
								]
							}
						}
					]
				}
			],
			"description": "This Postman collection is designed to help multi-tenant Duo customers in managing their shared MSP (Managed Service Provider) users for client application access. It provides a workflow to add a list of shared Duo user accounts to a target account, import a list of phone numbers (likely owned by indivivudal techs), and attaches those numbers to each shared Duo user on the target account.\n\nFollow these steps to utilize the collection:\n\n**Onboarding: Used to attach a list of phone numbers to a list of shared Duo users accounts**\n\n1. **Set Child Account Name:**\n    \n    - On the Variables tab of the Duo Administrative Tasks collection, input the desired account name for a valid child account in the `child_account_name` variable. (Note: Use the Retrieve Accounts request to pull a list of child accounts and copy/paste it.)\n        \n2. **Create MSP Users: Creates a list of users on the target** account\n    \n    - Navigate to the Body tab of the Create MSP Users request and adjust the example JSON with the desired user name details.\n    - Modify the example JSON list to define the list of users to be imported into Duo.\n    - Click Send to deploy a list of shared admin accounts via the API to the designated child account.\n        \n3. **Create MSP Phones: Creates a list of phone numbers on target account**\n    \n    - Head to the Body tab of Create MSP Phones and provide a list of names and phone numbers for each individual.\n    - Ensure the input is a valid JSON format.\n    - Click Send to add the list of phone numbers to the target account and send Duo Mobile activation codes to the owners of the phone numbers.\n4. **Attach MSP Phones to MSP Users: Assigns the list of phone IDs to the list of created users**\n    \n    - This request attaches the list of phone IDs added in the previous step to each individual MSP shared user account imported in the Create MSP Users request.\n\n**Offboarding: Remove a individual phone number from each child account**\n\n1. **Get Phone Report:**\n    \n    - Provide a phone number in +15556667777 format to pull a list of child accounts where the specified phone number is found.\n    - The response will yield a list of accounts and store the phone IDs for this number from each account.\n2. **Delete Phone:**\n    \n    - Using the list of phone IDs, the request loops through each account where the number was found and deletes that number.",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							"function getAuthHeader(httpMethod, requestUrl, requestBody) {",
							"    var IKEY = pm.globals.get(\"accounts_api_ikey\"); //Auth or Admin API IKEY",
							"    var SKEY = pm.globals.get(\"accounts_api_skey\"); //Auth or Admin API SKEY",
							"    var API_HOSTNAME = pm.globals.get(\"accounts_api_host\"); //Auth or Admin API Hostname",
							"    var AUTH_TYPE = 'HMAC-SHA1'; // Define the authentication type",
							"",
							"    // Check if the API hostname is defined. If not, throw an error.",
							"    if (!API_HOSTNAME) {",
							"        throw new Error(\"API_HOSTNAME is not defined\");",
							"    }",
							"     ",
							"    //Adds a ? at the end of the URL even if there aren't any parameters, makes it easier to find the end of the api_call",
							"    if (requestUrl.indexOf(\"?\") == -1) {",
							"        requestUrl += \"?\";",
							"    }",
							"",
							"    // Get the index of the start of the query parameters in the URL ",
							"    var paramsStart = requestUrl.indexOf(\"?\");",
							"",
							"    // Calculate the length of the hostname",
							"    var hostname_length = requestUrl.indexOf(API_HOSTNAME) + API_HOSTNAME.length;",
							"",
							"    // Extract the API endpoint from the requestUrl, by removing the hostname and the query parameters",
							"    var api_call = requestUrl.slice(hostname_length, paramsStart);  //remove hostname and params to get the api_call",
							"     ",
							"    // Clean up api_call by removing any unwanted characters",
							"    api_call = api_call.replace(\"}}\", \"\");",
							"    // console.log('api_call:', api_call);",
							"",
							"    var params_unsorted = \"\";",
							"    var params_array = [];",
							"    //Create unsorted array of parameters from either URL or Body",
							"    //Assuming POST parameters are in the Body, GET paramters are in URL",
							"    //(technically it looks like POST can be in the URL as well)",
							"",
							"    // Depending on the HTTP method and the existence of a request body,",
							"    // extract the query parameters from the URL or the body into params_array",
							"    if (httpMethod === \"POST\" && Object.keys(requestBody).length !== 0) {",
							"        for (var parameter1 in requestBody) {",
							"            params_unsorted = parameter1 + \"=\" + requestBody[parameter1];",
							"            params_array.push(params_unsorted);",
							"        }",
							"    } else {",
							"        params_unsorted = requestUrl.substring(paramsStart+1);",
							"        params_array = params_unsorted.split(\"&\");",
							"    }",
							"     ",
							"    params_array.sort();                    //lexicographically sort parameters by key",
							"    var encoded_params = \"\";               ",
							"    if (params_array[0] !== \"\"){ //check if there are any Params to encode and create the string from",
							"        var encoded_params_array = params_array.map(urlEncodeParams);  //create URL-encoded array of key=value pairs from the sorted array",
							"        encoded_params = encoded_params_array.join(\"&\");  //create string of parameters joined by &",
							"    }",
							"     ",
							"    // Get the current timestamp in the RFC 2822 format and store it in a collection variable for later use",
							"    var moment = require('moment');",
							"    var timestamp = moment().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\");",
							"    pm.globals.set(\"timestampHeader\",timestamp);",
							" ",
							"    // Construct the canonical string that is to be signed, by concatenating several request elements with newlines",
							"    var requestData =  timestamp+\"\\n\"+httpMethod+\"\\n\"+API_HOSTNAME+\"\\n\"+api_call+\"\\n\"+encoded_params;",
							"    // console.log(requestData);",
							" ",
							"    // Compute the HMAC-SHA1 signature of the canonical string, using SKEY as the HMAC key",
							"    var CryptoJS = require('crypto-js');",
							"    var hmacDigest = CryptoJS.HmacSHA1(requestData, SKEY);",
							"     ",
							"    //Use HTTP Basic Authentication for the request, using your integration key as the username and the HMAC-SHA1 signature as the password.",
							"    var prebase = IKEY+\":\"+ hmacDigest;",
							"    // console.log(\"prebase:\", prebase)",
							"     ",
							"    //encodes a string in base-64",
							"    var btoa = require('btoa');",
							"    var baseComplete = btoa(prebase);",
							"",
							"    var authHeader = \"Basic \"+ baseComplete;",
							"    return authHeader;",
							"}",
							"",
							"function urlEncodeParams(value, index, array) {",
							"    return value.split(/=(.+)/)[0] + \"=\" + encodeURIComponent(value.split(/=(.+)/)[1]);",
							"}",
							"",
							"// Get Accounts",
							"// Performing this request to pull the list of child accounts",
							"    var url1 = `https://${pm.globals.get(\"accounts_api_host\")}/accounts/v1/account/list`;",
							"",
							"    pm.globals.set(\"hmacAuthHeader\", getAuthHeader(\"POST\", url1, {}));",
							"",
							"    pm.sendRequest({",
							"    url: url1,",
							"    method: \"POST\",",
							"    header: {",
							"        \"Content-Type\": \"application/x-www-form-urlencoded\",",
							"        \"Authorization\": pm.globals.get(\"hmacAuthHeader\"),",
							"        \"Date\": pm.globals.get(\"timestampHeader\")",
							"    },",
							"    body: {}",
							"    }, function(err, res) {",
							"    if (err) {",
							"        console.log(\"Error:\", err);",
							"        return;",
							"    }",
							"",
							"    // console.log(\"Response Status Code:\", res.code);",
							"    // console.log(\"Raw Response Body:\", res.text());",
							"",
							"    try {",
							"        var responseJson = JSON.parse(res.text());",
							"        if (responseJson.stat === \"OK\") {",
							"            // Initialize an object to store the mapping",
							"            var duoChildAccounts = {};",
							"",
							"            for (var i = 0; i < responseJson.response.length; i++) {",
							"                var accountId = responseJson.response[i].account_id;",
							"                var accountName = responseJson.response[i].name;",
							"                var apiHostname = responseJson.response[i].api_hostname;",
							"",
							"                // Store the account ID, name, and API hostname mapping in duoChildAccounts",
							"                duoChildAccounts[accountId] = {",
							"                    name: accountName,",
							"                    apiHostname: apiHostname",
							"                };",
							"            }",
							"",
							"            // Save the mapping object as a global variable",
							"            pm.collectionVariables.set(\"duoChildAccounts\", JSON.stringify(duoChildAccounts));",
							"        } else {",
							"            console.log(\"Unexpected 'stat' value:\", responseJson.stat);",
							"        }",
							"    } catch (error) {",
							"        console.log(\"Error parsing JSON:\", error);",
							"    }",
							"});",
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "parent_account_edition",
			"value": "",
			"type": "string"
		},
		{
			"key": "discount_tier",
			"value": "",
			"type": "string",
			"disabled": true
		},
		{
			"key": "nfr_adjustment",
			"value": "",
			"type": "string",
			"disabled": true
		},
		{
			"key": "child_account_name",
			"value": ""
		},
		{
			"key": "pushPhishGroup",
			"value": "",
			"type": "string",
			"disabled": true
		},
		{
			"key": "phone_id_search",
			"value": "",
			"type": "string"
		},
		{
			"key": "duoChildAccounts",
			"value": ""
		},
		{
			"key": "shared_msp_users",
			"value": ""
		},
		{
			"key": "msp_phone_numbers",
			"value": ""
		},
		{
			"key": "phone_id_list",
			"value": ""
		}
	]
}